#+title: bauer: an Emacs+Nix IDE
#+author: Matthew Bauer
#+email: mjbauer95@gmail.com
#+subtitle: Bauer’s Automated Unified Emacs Realm
#+description: My Emacs configuration
#+language: en
#+options: c:nil d:t e:t f:t H:3 p:nil ':t *:t -:t ::t <:t \n:nil ^:{} |:t
#+options: arch:nil author:t broken-links:nil
#+options: creator:t date:t email:t inline:nil num:nil pri:t
#+options: prop:nil stat:t tags:nil tasks:nil tex:t timestamp:t title:t toc:nil
#+property: header-args :cache yes :comments link
#+property: header-args:emacs-lisp :results output silent
#+latex_header: \usepackage{parskip}
#+latex_header: \usepackage{inconsolata}
#+latex_header: \usepackage[utf8]{inputenc}
#+latex_header: \usepackage{alltt}
#+latex_header: \usepackage{upquote}
#+tags: noexport notangle
#+startup: hideblocks align entitiespretty
#+export_file_name: index
#+keywords: dotfiles config ide emacs nix bauer
#+html_head: <link rel="stylesheet" href="https://matthewbauer.us/style.css" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" />
#+link_home: http://matthewbauer.us
#+link_up: http://matthewbauer.us/bauer/

This ORG-mode file generates an Emacs configuration. I am calling it an
[[https://www.gnu.org/s/emacs/][Emacs]]+[[https://nixos.org][Nix]] IDE. That is, the Emacs configuration is /integrated/ with hardcoded
Nix store paths. This provides a kind of functional Emacs configuration. The
integration between Emacs & Nix comes with lots of useful side effects. The raw
Org file can always be downloaded [[https://matthewbauer.us/bauer/README.org][here]]. You can create pull requests & issues on
[[https://github.com/matthewbauer/bauer][the GitHub repo]]. You can access my website at https://matthewbauer.us.

#+TOC: headlines 2

* Usage
:PROPERTIES:
:header-args: :tangle no
:CUSTOM_ID: usage
:END:

** Installing/upgrading
:PROPERTIES:
:CUSTOM_ID: install
:END:

This is the script that I use to setup all of my new machines but it's portable
enough for anyone to use.

To install, just run this command from your shell:

#+BEGIN_SRC shell
curl https://matthewbauer.us/bauer/install | sh
#+END_SRC

Once it’s installed, you can open Emacs at any time with this command:

#+BEGIN_SRC shell
$HOME/.nix-profile/bin/run
#+END_SRC

If you don't like it, it's also very easy to uninstall. Just run:

#+BEGIN_SRC shell
nix-env -e bauer
nix-collect-garbage -d
#+END_SRC

** Developing
:PROPERTIES:
:CUSTOM_ID: develop
:END:

After you’ve installed it, it’s easy to make changes. By default, the
configuration lives in =~/.local/share/bauer=. To make changes just follow this
process,

#+BEGIN_SRC shell
cd ~/.local/share/bauer
nix-build
./result/run README.org
#+END_SRC

The last line will spawn an Emacs frame in the Git repo. Anything in that file
can be change. Once you’ve made a change, just run =M-x dev-restart= to rebuild
the configuration & restart Emacs. Make any changes you want to [[./README.org][the README.org
file]] or any of the files in [[./site-lisp][the site-lisp folder]]. Make sure you commit your
changes afterward by typing =C-c p v=, then =c-ac=. If you have already forked
[[https://github.com/matthewbauer/bauer][this repo on GitHub]], you can add it as a remote by typing =Mg= followed by your
GitHub username within Magit. To push to it, just type =Pr= then find your
username in the list & press enter. Pull requests are always welcome through
GitHub!

** Without Nix
:PROPERTIES:
:CUSTOM_ID: nonix
:header-args: :tangle no
:END:

You can also use this configuration without Nix. This just gives you the Emacs
configuration without any of the Nix integrations. All of the binaries will have
to be provided externally. To get started, run the following:

#+BEGIN_SRC shell
mv ~/.emacs.d ~/.emacs.d.old
git clone https://github.com/matthewbauer/bauer \
          ~/.emacs.d
#+END_SRC

* Emacs init file
:PROPERTIES:
:header-args: :tangle yes :comments link
:CUSTOM_ID: emacs
:END:

This is the main part of the IDE. It is written in Emacs lisp & will be loaded
every time Emacs is started.

** Increase GC

Increasing GC is a common way to speed up Emacs. =gc-cons-threshold= sets at
what point Emacs should invoke its garbage collector Some people set it to a
really larger number permanently. This works well until the garbage is actually
collected (then you have to wait a long time). I’ve decided to just set it
temporarily to a large number so we only garbage collect once on startup. After
that we reset it to the standard value. Read [[http://bling.github.io/blog/2016/01/18/why-are-you-changing-gc-cons-threshold/][@bling’s post]] for more info on
this.

#+BEGIN_SRC emacs-lisp :padline no
  ;; -*- mode: emacs-lisp; coding: utf-8; -*-

  (defvar file-name-handler-alist-backup
          file-name-handler-alist)
  (setq gc-cons-threshold
          most-positive-fixnum
        file-name-handler-alist nil)
  (add-hook 'after-init-hook
    (lambda ()
      (garbage-collect)
      (setq gc-cons-threshold
              (car (get 'gc-cons-threshold 'standard-value))
        file-name-handler-alist
          (append
            file-name-handler-alist-backup
            file-name-handler-alist))))
#+END_SRC

** Autoloads & Misc.

Setup some initial aliases for Emacs. These give us an easy way to use these
functions without actually require'ing them. Ideally, Emacs should pick these up
through the automatic autoloading method, but that sometimes conflicts with the
compiling phases used later.

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (autoload 'package-installed-p "package")
    (autoload 'use-package-autoload-keymap "use-package")
    (autoload 'pcomplete-arg   "pcomplete")
    (autoload 'pcomplete--here "pcomplete")
    (autoload 'tramp-tramp-file-p "tramp")
    (autoload 'tramp-dissect-file-name "tramp"))
#+END_SRC

Now we are going to setup some basic Emacs GUI elements. Under normal
circumstances, we want GUI elements hidden from the user so that we only see the
text buffer. This gives us a minimalist look that works well with the theme. We
will end up disabling =tool-bar-mode=, =scroll-bar-mode=, =blink-cursor-mode=,
& =menu-bar-mode= here. The one exception to this is when we are running macOS
where the system provides a builtin menubar system that Emacs can use.

#+BEGIN_SRC  emacs-lisp
  (when window-system
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (blink-cursor-mode -1))

  (when (not (memq window-system '(mac ns)))
    (menu-bar-mode -1))
#+END_SRC

When we are within a terminal we want to be able to use the mouse, so
=xterm-mouse-mode= is enabled here.

#+BEGIN_SRC  emacs-lisp
  (when (not window-system)
    (xterm-mouse-mode 1))
#+END_SRC

** Custom config

[[./lisp/set-defaults.el][set-defaults]] provides an easy way to override the default custom files. This
means that when you customize a variable it will appear as ‘standard’ even
though it’s not what the package originally defined as the default. This is
useful for an Emacs distribution to provide /better defaults/ while still
letting the user override them. Look through the lispdoc of the package for
documentation on how this works. Eventually, this will be added to MELPA for use
in other Emacs distributions.

#+BEGIN_SRC emacs-lisp
  (require 'set-defaults)
#+END_SRC

*** Better defaults

These are some *better* defaults for Emacs. They shouldn’t require any packages
to be installed to work (those go in use-package). In addition, they should take
almost no time to run (meaning they probably shouldn’t have custom init hooks).
The format of arguments to =set-defaults= is identical to the one used by
=custom-set-variables=.

#+BEGIN_SRC emacs-lisp
  (set-defaults
   '(TeX-auto-save t)
   '(TeX-auto-untabify t)
   '(TeX-electric-escape t)
   '(TeX-parse-self t)
   '(ad-redefinition-action 'accept)
   '(apropos-do-all t)
   '(async-shell-command-buffer 'new-buffer)
   '(auth-source-save-behavior t)
   '(auto-revert-check-vc-info t)
   '(auto-revert-verbose nil)
   '(auto-save-visited-file-name t)
   '(ange-ftp-default-user t)
   '(auto-window-vscroll nil)
   '(bug-reference-bug-regexp
     "\\(\\(?:[Ii]ssue \\|[Ff]ixe[ds] \\|[Rr]esolve[ds]? \\|[Cc]lose[ds]?\\|[Pp]\\(?:ull [Rr]equest\\|[Rr]\\) \\|(\\)#\\([0-9]+\\))?\\)")
   '(backward-delete-char-untabify-method 'hungry)
   '(backup-directory-alist `(("." .
			       ,(expand-file-name "backup"
						  user-emacs-directory))))
   '(checkdoc-spellcheck-documentation-flag t)
   '(company-auto-complete (lambda ()
			     (and (company-tooltip-visible-p)
				  (company-explicit-action-p))))
   '(company-continue-commands
     '(not save-buffer
	   save-some-buffers
	   save-buffers-kill-terminal
	   save-buffers-kill-emacs
	   comint-previous-matching-input-from-input
	   comint-next-matching-input-from-input))
   '(company-require-match nil)
   '(company-selection-wrap-around t)
   '(company-backends '(company-elisp
			company-css
			company-nxml
			company-cmake
			(company-capf
			 company-files
			 company-keywords
			 company-dabbrev-code)
			;; company-dabbrev
			))
   '(comint-input-ignoredups t)
   '(comint-process-echoes t)
   '(comint-prompt-read-only t)
   '(comint-scroll-show-maximum-output nil)
   '(compilation-always-kill t)
   '(compilation-ask-about-save nil)
   '(compilation-environment '("TERM=xterm-256color"))
   '(compilation-skip-threshold 2)
   '(completion-styles '(basic
			 partial-completion
			 emacs22
			 substring))
   '(completions-cycle-threshold t)
   '(completions-format 'vertical)
   '(counsel-find-file-at-point t)
   '(counsel-mode-override-describe-bindings t)
   '(create-lockfiles nil)
   '(cursor-in-non-selected-windows nil)
   '(custom-buffer-done-kill t)
   '(custom-file (expand-file-name
		  "settings.el"
		  user-emacs-directory))
   '(custom-safe-themes t)
   '(custom-search-field nil)
   '(delete-by-moving-to-trash t)
   '(delete-old-versions t)
   ;; '(dired-auto-revert-buffer t)
   '(dired-dwim-target t)
   '(dired-hide-details-hide-symlink-targets nil)
   '(dired-listing-switches "-alhv")
   '(dired-omit-files "^\\.\\|^#.*#$")
   '(dired-omit-verbose nil)
   '(dired-recursive-copies 'always)
   '(dired-recursive-deletes 'always)
   '(dired-subtree-line-prefix " ")
   '(disabled-command-function nil)
   '(display-buffer-reuse-frames t)
   '(dtrt-indent-verbosity 0)
   '(echo-keystrokes 0)
   '(enable-recursive-minibuffers t)
   '(erc-autojoin-timing 'ident)
   '(erc-interpret-mirc-color t)
   '(erc-join-buffer 'bury)
   '(erc-kill-buffer-on-part t)
   '(erc-kill-queries-on-quit t)
   '(erc-kill-server-buffer-on-quit t)
   '(erc-log-write-after-send t)
   '(erc-prompt (lambda nil (concat "[" (buffer-name) "]")))
   '(erc-prompt-for-password nil)
   '(erc-query-display 'buffer)
   '(erc-rename-buffers t)
   '(erc-track-exclude-server-buffer t)
   '(erc-track-exclude-types '("JOIN" "NICK" "PART"
			       "QUIT" "MODE" "333" "353"))
   '(erc-track-remove-disconnected-buffers t)
   '(erc-track-position-in-mode-line t)
   '(erc-timestamp-format "%H:%M ")
   '(erc-timestamp-only-if-changed-flag nil)
   '(erc-try-new-nick-p nil)
   '(erc-user-full-name 'user-full-name)
   '(eshell-history-size 1000)
   '(eshell-output-filter-functions '(eshell-handle-ansi-color
				      eshell-watch-for-password-prompt
				      eshell-truncate-buffer))
   '(eshell-scroll-show-maximum-output nil)
   '(eshell-visual-commands
     '("vi" "screen" "top" "less" "more" "lynx" "ncftp" "pine" "tin"
       "trn" "elm" "ssh" "mutt" "tmux" "htop" "fish"
       "alsamixer" "watch" "elinks" "links" "nethack" "vim" "zsh"))
   '(eshell-visual-options nil)
   '(eshell-visual-subcommands '(("nix" "build" "repl") ("vagrant" "ssh")))
   '(eshell-banner-message "")
   '(eshell-cmpl-autolist t)
   '(eshell-cmpl-cycle-completions nil)
   '(eshell-cmpl-cycle-cutoff-length 2)
   '(eshell-cmpl-ignore-case t)
   '(eshell-cp-overwrite-files nil)
   '(eshell-default-target-is-dot t)
   '(eshell-destroy-buffer-when-process-dies t)
   '(eshell-hist-ignoredups t)
   '(eshell-list-files-after-cd t)
   '(eshell-ls-dired-initial-args '("-h"))
   '(eshell-ls-initial-args "-h")
   '(eshell-review-quick-commands t)
   '(eshell-prompt-function
     (lambda ()
       (concat (when (tramp-tramp-file-p default-directory)
		 (concat
		  (tramp-file-name-user
		   (tramp-dissect-file-name default-directory))
		  "@"
		  (tramp-file-name-host
		   (tramp-dissect-file-name default-directory))
		  " "))
	       (let ((dir (eshell/pwd)))
		 (if (string= dir (getenv "HOME")) "~"
		   (let ((dirname (file-name-nondirectory dir)))
		     (if (string= dirname "") "/" dirname))))
	       (if (= (user-uid) 0) " # " " $ "))))
   '(eshell-save-history-on-exit t)
   '(eshell-stringify nil)
   '(eshell-term-name "ansi")
   '(eshell-visual-commands '("vi" "top" "screen" "less"
			      "rlogin" "telnet" "lynx"))
   '(eshell-history-size 50000)
   '(eval-expression-print-level nil)
   '(expand-region-contract-fast-key "j")
   '(explicit-shell-args
     '("-c" "export EMACS= INSIDE_EMACS=; stty echo; shell"))
   '(find-ls-option '("-print0 | xargs -P4 -0 ls -ldN" . "-ldN"))
   '(find-ls-subdir-switches "-ldN")
   '(flycheck-display-errors-function
     'flycheck-display-error-messages-unless-error-list)
   '(flycheck-global-modes '(not erc-mode
				 message-mode
				 git-commit-mode
				 view-mode
				 outline-mode
				 text-mode
				 org-mode))
   '(flycheck-standard-error-navigation nil)
   '(flyspell-highlight-properties nil)
   '(flyspell-issue-welcome-flag nil)
   '(frame-title-format
     '(:eval
       (if (buffer-file-name)
	   (abbreviate-file-name (buffer-file-name))
	 "%b")))
   '(gnuplot-inline-image-mode 'dedicated)
   '(haskell-interactive-mode-scroll-to-bottom t)
   '(haskell-process-type 'ghci)
   '(haskell-process-load-or-reload-prompt t)
   '(haskell-process-suggest-haskell-docs-imports t)
   '(haskell-process-suggest-hoogle-imports t)
   '(haskell-process-suggest-remove-import-lines t)
   '(help-window-select t)
   '(hideshowvis-ignore-same-line nil)
   '(highlight-nonselected-windows nil)
   '(history-delete-duplicates t)
   '(ibuffer-default-display-maybe-show-predicates t)
   '(ibuffer-expert t)
   '(ibuffer-formats
     '((mark modified read-only " " (name 16 -1) " "
	     (size 6 -1 :right) " " (mode 16 16) " " filename)
       (mark " " (name 16 -1) " " filename)))
   '(ibuffer-maybe-show-regexps nil)
   '(ibuffer-show-empty-filter-groups nil)
   '(ibuffer-shrink-to-minimum-size t)
   '(ibuffer-use-other-window t)
   '(iedit-toggle-key-default nil)
   '(imenu-auto-rescan t)
   '(indicate-empty-lines t)
   '(inhibit-startup-echo-area-message t)
   '(inhibit-startup-screen t)
   '(initial-scratch-message "")
   '(initial-major-mode 'fundamental-mode)
   '(ispell-extra-args '("--sug-mode=ultra"))
   '(ispell-quietly t)
   '(ispell-silently-savep t)
   '(jit-lock-defer-time 0.25)
   '(js2-mode-show-parse-errors nil)
   '(js2-mode-show-strict-warnings nil)
   '(js2-strict-missing-semi-warning nil)
   '(kill-do-not-save-duplicates t)
   '(kill-whole-line t)
   '(load-prefer-newer t)
   '(mac-allow-anti-aliasing t)
   '(mac-command-key-is-meta t)
   '(mac-command-modifier 'meta)
   '(mac-frame-tabbing t)
   '(mac-option-key-is-meta nil)
   '(mac-option-modifier 'super)
   '(mac-right-option-modifier nil)
   '(magit-remote-add-set-remote\.pushDefault t)
   '(magit-clone-set-remote\.pushDefault t)
   '(magit-ediff-dwim-show-on-hunks t)
   '(magit-highlight-trailing-whitespace nil)
   '(magit-highlight-whitespace nil)
   '(magit-log-auto-more t)
   '(magit-no-confirm t)
   '(magit-process-find-password-functions
     '(magit-process-password-auth-source))
   '(magit-process-popup-time 15)
   '(magit-save-repository-buffers 'dontask)
   '(magit-stage-all-confirm nil)
   '(magit-unstage-all-confirm nil)
   '(magit-blame-disable-modes '(fci-mode view-mode yascroll-bar-mode))
   '(mode-line-default-help-echo nil)
   '(mmm-global-mode 'buffers-with-submode-classes)
   '(mmm-submode-decoration-level 2)
   '(minibuffer-prompt-properties
     '(read-only t
		 cursor-intangible t
		 face minibuffer-prompt))
   '(next-error-recenter t)
   '(notmuch-show-logo nil)
   '(nrepl-log-messages t)
   '(ns-function-modifier 'hyper)
   '(ns-pop-up-frames nil)
   '(nsm-save-host-names t)
   '(nxml-sexp-element-flag t)
   '(nxml-slash-auto-complete-flag t)
   '(org-confirm-babel-evaluate nil)
   '(org-edit-src-turn-on-auto-save t)
   '(org-export-with-toc nil)
   '(org-html-htmlize-output-type 'css)
   '(org-latex-listings 'minted)
   '(org-log-done 'time)
   '(org-special-ctrl-a/e t)
   '(org-support-shift-select t)
   '(package-archives
     '(("melpa" . "https://melpa.org/packages/")
       ("org" . "http://orgmode.org/elpa/")
       ("gnu" . "https://elpa.gnu.org/packages/")))
   '(pcomplete-compare-entries-function 'file-newer-than-file-p)
   '(projectile-globally-ignored-files '(".DS_Store" "TAGS"))
   '(projectile-ignored-project-function 'file-remote-p)
;;   '(projectile-enable-idle-timer 1)
   '(projectile-mode-line
     '(:eval
       (if (and (ignore-errors (projectile-project-p))
		(not (file-remote-p default-directory)))
	   (format " Projectile[%s]"
		   (projectile-project-name))
	 "")))
   '(projectile-switch-project-action 'projectile-dired)
   '(projectile-verbose nil)
   '(proof-auto-action-when-deactivating-scripting 'retract)
   '(proof-autosend-enable nil)
   '(proof-electric-terminator-enable t)
   '(proof-fast-process-buffer nil)
   '(proof-script-fly-past-comments t)
   '(proof-shell-fiddle-frames nil)
   '(proof-splash-enable nil)
   '(proof-sticky-errors t)
   '(proof-tidy-response t)
   '(reb-re-syntax 'string)
   '(resize-mini-windows t)
   '(ring-bell-function 'ignore)
   '(ruby-insert-encoding-magic-comment nil)
   '(save-abbrevs 'silently)
   '(save-interprogram-paste-before-kill t)
   '(savehist-additional-variables '(search-ring
				     regexp-search-ring
				     kill-ring
				     comint-input-ring
				     kmacro-ring
				     sr-history-registry
				     file-name-history
				     tablist-name-filter))
   '(savehist-ignored-variables
     '(load-history flyspell-auto-correct-ring kill-ring))
   '(savehist-save-minibuffer-history t)
   '(scroll-preserve-screen-position 'always)
   '(scroll-conservatively 101)
   '(sentence-end-double-space nil)
   '(set-mark-command-repeat-pop t)
   '(shell-completion-execonly nil)
   '(shell-input-autoexpand nil)
   '(sh-learn-basic-offset t)
   ;; '(show-paren-delay 0)
   '(sp-autoskip-closing-pair 'always)
   '(sp-highlight-pair-overlay nil)
   '(switch-to-buffer-preserve-window-point t)
   '(tab-always-indent 'complete)
   '(term-input-autoexpand t)
   '(term-input-ignoredups t)
   '(term-input-ring-file-name t)
   '(text-quoting-style 'quote)
   '(tramp-default-proxies-alist
     '(((regexp-quote (system-name)) nil nil)
       (nil "\\`root\\'" "/ssh:%h:")
       (".*" "\\`root\\'" "/ssh:%h:")))
   '(tls-checktrust t)
   '(uniquify-buffer-name-style 'forward)
   '(uniquify-ignore-buffers-re "^\\*")
   '(uniquify-separator "/")
   '(use-dialog-box nil)
   '(use-file-dialog nil)
   '(use-package-always-defer t)
   '(version-control t)
   '(vc-allow-async-revert t)
   '(vc-command-messages t)
   '(vc-git-diff-switches '("-w" "-U3"))
   '(vc-follow-symlinks nil)
   '(vc-ignore-dir-regexp
     (concat "\\(\\(\\`"
	     "\\(?:[\\/][\\/][^\\/]+[\\/]\\|/"
	     "\\(?:net\\|afs\\|\\.\\.\\.\\)/\\)"
	     "\\'\\)\\|\\(\\`/[^/|:][^/|]*:\\)\\)\\|\\"
	     "(\\`/[^/|:][^/|]*:\\)"))
   '(vc-make-backup-files t)
   '(view-read-only t)
   '(view-inhibit-help-message t)
   '(woman-imenu t)
   '(x-stretch-cursor t)
   '(which-key-lighter "")
   '(whitespace-action '(cleanup auto-cleanup))
   '(whitespace-style '(face trailing lines space-before-tab
			     empty lines-style))
   '(fortune-always-compile nil)
   )
#+END_SRC

*** Site paths

Now, pull in generated paths from =site-paths.el=. Nix will generate this file
automatically for us & different Emacs variables will be set to their Nix
store derivation paths. Everything should work fine if you don’t have this
available, though. If you are in Emacs & already have the IDE installed you
can inspect this file by typing =C-h C-l site-paths=. It will look similar to a
=settings.el= file where each line corresponds to a customizable variable.
Unlike =settings.el=, each entry is path in the Nix store & we verify it
exists before setting it.

#+BEGIN_SRC emacs-lisp
  (load "site-paths" t)
#+END_SRC

*** Set environment

=set-envs= is provided by [[./lisp/set-defaults.el][set-defaults]]. We can use it like
=custom-set-variables=, just it calls =setenv= instead of =setq=. All of
these entries correspond to environment variables that we want to always be
set in the Emacs process.

#+BEGIN_SRC emacs-lisp
  (set-envs
   '("EDITOR" "emacsclient")
   '("LANG" "en_US.UTF-8")
   '("LC_ALL" "en_US.UTF-8")
   '("NODE_NO_READLINE" "1")
   '("PAGER" "cat")
   '("PS1" "\\W > ")
   )
#+END_SRC

Fix broken Git on Windows.

#+BEGIN_SRC emacs-lisp
(when (eq window-system 'w32)
  (setenv "GIT_ASKPASS" "git-gui--askpass"))
#+END_SRC

*** Load custom file

This file allows users to override the above defaults. This will mean you
can use custom as you normally would in vanilla Emacs.

#+BEGIN_SRC emacs-lisp
  (load custom-file t)
#+END_SRC

** Setup use-package

[[https://github.com/jwiegley/use-package][use-package]] is an Emacs package by John Weigley allowing users to easily
configure other Emacs packages. It’s quite useful & it will be used
extensively in this project.

Now to get =use-package= we will require =package.el= & initialize it if
site-paths is not setup (meaning we’re outside the Nix expression). Because
site-paths should be available (unless you don’t have Nix), we can skip this
step. All of this is marked ‘eval-and-compile’ to make sure the compiler picks
it up on build phase.

So, there are basically two modes for using this configuration. One when
packages are installed externally (through Nix) & another where they are
installed internally. This is captured in the variable ‘needs-package-init’
which will be t when we want to use the builtin package.el & will be nil when
we want to just assume everything is available.

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (setq needs-package-init
          (and (not (locate-library "site-paths"))
	           (not (and
                      (boundp 'use-package-list--is-running)
                      use-package-list--is-running)))))
#+END_SRC

First handle using =package.el=. We will do all of the work of bootstrapping
here including running =package-initialize=, ensuring =use-package=, & =delight=
are installed.

#+BEGIN_SRC emacs-lisp
  (when needs-package-init
    (require 'package)
    (package-initialize)
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))
    (unless (package-installed-p 'delight)
      (package-refresh-contents)
      (package-install 'delight)))
#+END_SRC

Actually require =use-package=,

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (require 'delight)
    (require 'bind-key)
    (require 'use-package))
#+END_SRC

Now let’s handle the case where all of the packages are already provided.
Basically, we’ll prevent use-package from running ‘ensure’ on anything.

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (setq use-package-always-ensure needs-package-init)
    (when (not needs-package-init)
      (setq use-package-ensure-function 'ignore
            package-enable-at-startup nil
            package--init-file-ensured t)))
#+END_SRC

** Key bindings

Using bind-key, setup some simple key bindings. None of these should overwrite
Emacs’ default keybindings. Also, they should only require vanilla Emacs to work
(non-vanilla Emacs key bindings should be put in their =use-package=
declaration). These are meant to all be as close to vanilla Emacs as possible. I
try to avoid extremely specific key binds here.

What is overwritten can be seen with =M-x describe-personal-keybindings=. The
goal is to overwrite as little as possible. When it is necessary to overwrite
Emacs keybinds, documentation on why should be provided.

First we include a library that provides some nice helper functions that will be
used as key bindings.

#+BEGIN_SRC emacs-lisp
  (require 'bauer)
#+END_SRC

Now we will call =bind-keys=. We give it keys to bind & what function to run
when those keys are pressed. Note on syntax of bind-keys: if you are unfamiliar
with how Emacs key binding works, you should read through [[https://www.masteringemacs.org/article/mastering-key-bindings-emacs][this article]].

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'ns-drag-n-drop-as-text)
    (global-set-key [M-s-drag-n-drop]
		   'ns-drag-n-drop-as-text))
  (bind-keys
   ("C-c C-u" . rename-uniquely)
   ("C-x ~" . (lambda () (interactive) (find-file "~")))
   ("C-x /" . (lambda () (interactive) (find-file "/")))
   ("C-x 4 C-x ~" . (lambda () (interactive) (find-file-other-window "~")))
   ("C-x 4 C-x /" . (lambda () (interactive) (find-file-other-window "/")))
   ("C-c C-o" . browse-url-at-point)
   ("H-l" . browse-url-at-point)
   ("C-x 5 3" . iconify-frame)
   ("C-x 5 4" . toggle-frame-fullscreen)
   ("s-SPC" . cycle-spacing)
   ("C-c w w" . whitespace-mode)
   ("<C-return>" . other-window)
   ("s-o" . other-window)
   ("C-z" . delete-other-windows)
   ("M-g l" . goto-line)
   ("<C-M-backspace>" . backward-kill-sexp)
   ("C-x t" . toggle-truncate-lines)
   ("C-x v H" . vc-region-history)
   ("C-c SPC" . just-one-space)
   ("C-c f" . flush-lines)
   ("C-c o" . customize-option)
   ("C-c O" . customize-group)
   ("C-c F" . customize-face)
   ("C-c q" . fill-region)
   ("C-c s" . replace-string)
   ("C-c u" . rename-uniquely)
   ("C-c z" . clean-buffer-list)
   ("C-c =" . count-matches)
   ("C-c ;" . comment-or-uncomment-region)
   ("M-+" . text-scale-increase)
   ("M-_" . text-scale-decrease)

   ("H-c" . compile)
   ("s-c" . compile)
   ("s-r" . revert-buffer)
   ("s-1" . other-frame)
   ("<s-return>" . toggle-frame-fullscreen)

   ("s-C-<left>"  . enlarge-window-horizontally)
   ("s-C-<right>" . shrink-window-horizontally)
   ("s-C-<down>"  . shrink-window)
   ("s-C-<up>"    . enlarge-window)

   ("<S-s-up>"   . shrink-window)
   ("<S-s-down>" . enlarge-window)

   ("<s-down>"  . windmove-down)
   ("<s-up>"    . windmove-up)
   ("<s-left>"  . windmove-left)
   ("<s-right>" . windmove-right)

   ("C-c [" . align-regexp)
   ("M-s d" . find-grep-dired)
   ("M-s F" . find-grep)
   ("M-s G" . grep)
   ("s-/" . comment-or-uncomment-region)

   ("C-x M-p" . (lambda () (interactive)
		  (save-excursion (other-window 1)
				  (quit-window))))

   ("C-M--" . (lambda () (interactive)
		(update-font-size -1 t)))
   ("C-M-=" . (lambda () (interactive)
		(update-font-size 1 t)))
   ("C-M-0" . (lambda () (interactive)
		(update-font-size 12 nil)))

   ("M-n" . next-error)
   ("M-p" . previous-error)

   ("C-c m b" . eval-buffer)
   ("C-c m e" . eval-last-sexp)
   ("C-c m i" . eval-expression)
   ("C-c m d" . eval-defun)
   ("C-c m n" . eval-print-last-sexp)
   ("C-c m r" . eval-region)

   ("C-x r q"        . save-buffers-kill-terminal)
   ("C-c C-<return>" . delete-blank-lines)
   ("C-<f10>"        . menu-bar-mode)
   ("C-x M-g"        . browse-url-at-point)

   ("C-s"     . isearch-forward-regexp)
   ("C-r"     . isearch-backward-regexp)
   ("C-S-s"   . isearch-forward)
   ("C-S-r"   . isearch-backward)
   ("M-s l"   . sort-lines)
   ("M-s m"   . multi-occur)
   ("M-s M"   . multi-occur-in-matching-buffers)
   ("M-s f"   . find-name-dired)
   ("C-c i i" . imenu)
   ("C-c I"   . bauer-find-config))

  (bind-keys
   :package view
   :map view-mode-map
   ("n" . next-line)
   ("p" . previous-line)
   ("j" . next-line)
   ("k" . previous-line)
   ("l" . forward-char)
   ("f" . forward-char)
   ("b" . backward-char)
   ("e" . end-of-line)
   ("a" . beginning-of-line))

  (bind-keys
   :package iso-transl
   :map iso-transl-ctl-x-8-map
   ("' /"       . "′")
   ("\" /"      . "″")
   ("\" ("      . "“")
   ("\" )"      . "”")
   ("' ("       . "‘" )
   ("' )"       . "’" )
   ("4 < -"     . "←")
   ("4 - >"     . "→")
   ("4 b"       . "←")
   ("4 f"       . "→")
   ("4 p"       . "↑")
   ("4 n"       . "↓")
   ("<down>"    . "⇓")
   ("<S-down>"  . "↓")
   ("<left>"    . "⇐")
   ("<S-left>"  . "←")
   ("<right>"   . "⇒")
   ("<S-right>" . "→")
   ("<up>"      . "⇑")
   ("<S-up>"    .	"↑")
   (","         . "…"))

  (bind-keys
   :prefix-map bauer-git
   :prefix "s-g"
   ("l" . magit-clone)

   :prefix-map bauer-help
   :prefix "s-h"
   ("k" . describe-personal-keybindings)
   ("p" . ffap)
   ("m" . man)
   ("w" . woman))

  (unless window-system
    (global-set-key (kbd "<mouse-4>") 'scroll-down-line)
    (global-set-key (kbd "<mouse-5>") 'scroll-up-line))
#+END_SRC

** Setup installer

Installer provides installation & upgrading functionality. You can upgrade the
IDE at any time by typing =M-x upgrade= from within Emacs. You may have to
restart Emacs for the upgrade to take place. See [[./lisp/installer.el][installer.el]] for documentation.

#+BEGIN_SRC emacs-lisp
  (require 'installer nil t)
#+END_SRC

** Packages
:PROPERTIES:
:CUSTOM_ID: packages
:END:

Each of these entries are =use-package= calls that will both install & load
the package for us. The most important are listed first in “Essentials”.
“Built-in" Emacs packages are also configured. Next comes the “Programming
Language” modes. Finally, we list some miscellaneous modes.

This is an alphabetized listing of all Emacs packages needed by the IDE. To
resort, go to one of the package group headings & type =C-c ^ a=.

*** Essentials

These are the best & most useful modes available to us in Emacs world.

**** aggressive-indent
[[https://github.com/Malabarba/aggressive-indent-mode][GitHub]]

Automatically indent code as you type. Only enabled for Lisp currently.

#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :hook ((emacs-lisp-mode
	    inferior-emacs-lisp-mode
	    ielm-mode
	    lisp-mode
	    inferior-lisp-mode
	    isp-interaction-mode
	    slime-repl-mode) . aggressive-indent-mode))
#+END_SRC

**** Apropospriate Theme

[[https://github.com/waymondo/apropospriate-theme][GitHub]]

This is the theme I use & it works well for this configuration. It is dark
with high contrast. We will only enable it when we are running with GUI Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package apropospriate-theme
    :if window-system
    :init
    (add-to-list 'custom-theme-load-path
                 (file-name-directory
                   (locate-library "apropospriate-theme")))
    (load-theme 'apropospriate-dark t))
#+END_SRC

**** Company

[[http://company-mode.github.io][Website]]

Company provides completions in Emacs. Activate them by pressing =C-M-i=.

#+BEGIN_SRC emacs-lisp
  (load "company-autoloads" t t)
  (use-package company
    :commands global-company-mode
    :delight
    :demand
    :preface
    (defun company-complete-common-or-cycle-backward ()
      "Complete common prefix or cycle backward."
      (interactive)
      (company-complete-common-or-cycle -1))
    :bind (:map company-mode-map
		("C-M-i" . company-complete-common-or-cycle)
		:map company-active-map
		("RET" . company-complete-selection)
		([return] . company-complete-selection)
		("C-j" . company-complete-selection)

		("TAB" . company-complete-common-or-cycle)
		("<tab>" . company-complete-common-or-cycle)
		("S-TAB" . company-complete-common-or-cycle-backward)
		("<backtab>" . company-complete-common-or-cycle-backward)
		("C-n" . company-select-next)
		("C-p" . company-select-previous)

		("C-/" . company-search-candidates)
		("C-M-/" . company-filter-candidates)
		("C-d" . company-show-doc-buffer)
		)
    :hook ((minibuffer-setup . company-mode)
	   (minibuffer-setup .
			     (lambda () (setq-local company-frontends
					       '(company-preview-if-just-one-frontend))))
	   (after-init . global-company-mode)
	   ((shell-mode sh-mode fish-mode eshell-mode) .
	    (lambda ()
	      (setq-local company-backends
			  '((company-capf
			     company-files))))))
    :config
    (advice-add 'completion-at-point
		:override 'company-complete-common-or-cycle)
    (global-company-mode))
  (use-package readline-complete
    :disabled
    :commands company-readline
    :hook (shell-mode . (lambda ()
			  (setq-local company-backends '(company-readline)))))
  (use-package company-irony
    :commands company-irony
    :hook (irony-mode . (lambda ()
      (setq-local company-backends '(company-irony)))))
  (use-package company-shell
    :commands (company-shell company-fish-shell company-shell-env)
    :disabled)
  (use-package company-restclient
    :commands company-restclient
    :hook (restclient-mode . (lambda ()
      (setq-local company-backends '(company-restclient)))))
  (use-package company-anaconda
    :commands company-anaconda
    :hook (anaconda-mode . (lambda ()
			     (setq-local company-backends '((company-anaconda
							     company-capf))))))
  (use-package company-jedi
    :commands company-jedi
    :hook (python-mode . (lambda ()
      (setq-local company-backends '(company-jedi)))))
  (use-package company-tern
    :commands company-tern
    :hook (tern-mode . (lambda ()
      (setq-local company-backends '(company-tern)))))
  (use-package company-ghc
    :commands company-ghc
    :hook (haskell-mode . (lambda ()
      (setq-local company-backends '(company-ghc)))))
  (use-package company-auctex
    :commands (company-auctex
	       company-auctext-labels
	       company-auctest-bibs
	       company-auctex-macros
	       company-auctext-symbols
	       company-auctext-environments)
    :hook
    (tex-mode . (lambda ()
		  (setq-local company-backends '((company-auctex-labels
						  company-auctex-bibs
						  company-auctex-macros
						  company-auctex-environments
						  company-auctex-symbols))))))
  (use-package company-web
    :preface
    (autoload 'company-web-html "company-web-html")
    (autoload 'company-web-jade "company-web-jade")
    (autoload 'company-web-slim "company-web-slim")
    :hook ((web-mode . (lambda ()
			 (setq-local company-backends '(company-web-html
							company-web-jade
							company-web-slim))))))
  (use-package company-math
    :preface
    (autoload 'company-math-symbols-latex "company-math")
    (autoload 'company-latex-commands "company-math")
    :hook
    (TeX-mode . (lambda ()
		  (setq-local company-backends '((company-math-symbols-latex
						  company-latex-commands))))))
  (use-package company-coq
    :hook (coq-mode . company-coq-mode))
#+END_SRC
**** Counsel

[[https://github.com/abo-abo/swiper][GitHub]]

Counsel provides a better selection experience to the default Emacs.

Counsel is only enabled on non-Windows systems. This is due to an issue in
counsel-find-file, see https://github.com/abo-abo/swiper/issues/773 for more
info.

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :disabled
    :commands (counsel-mode counsel-descbinds
               counsel-grep-or-swiper)

    ;; counsel doesn’t work well with windows drives
    ;; see https://github.com/abo-abo/swiper/issues/773
    ;; :if (not (string= system-type "windows-nt"))

    :bind* (([remap execute-extended-command] . counsel-M-x)
	    ([remap find-library] . counsel-find-library)
	    ([remap describe-bindings]	.
             counsel-descbinds)
	    ([remap describe-face]  .
             counsel-describe-faces)
	    ([remap list-faces-display] . counsel-faces)
	    ([remap imenu] . counsel-imenu)
	    ([remap load-library] . counsel-load-library)
	    ([remap load-theme] . counsel-load-theme)
	    ([remap yank-pop] . counsel-yank-pop)
	    ([remap info-lookup-symbol] .
             counsel-info-lookup-symbol)
	    ([remap pop-to-mark-command] .
             counsel-mark-ring)
	    ([remap bookmark-jump] . counsel-bookmark)
	    ("C-c j" . counsel-git-grep)
	    ("C-x l" . counsel-locate)
	    ("M-y" . counsel-yank-pop)
	    ("C-c i 8" . counsel-unicode-char)
	    ("C-x M-f" . counsel-find-file)

	    :map help-map
	    ("C-v" . counsel-find-symbol)
	    ("C-k" . counsel-find-function-on-key)
	    ("C-l" . counsel-find-library)
	    ))
#+END_SRC

***** ivy

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :bind (([remap list-buffers] . ivy-switch-buffer)
	   ([remap switch-to-buffer] . ivy-switch-buffer)
	   ([remap switch-to-buffer-other-window] .
	    ivy-switch-buffer-other-window)
	   :package ivy
	   :map ivy-minibuffer-map
	   ("<escape>" . abort-recursive-edit))
    :init
    (defvar projectile-completion-system)
    (defvar magit-completing-read-function)
    (defvar projector-completion-system)
    (setq projectile-completion-system 'ivy
	  magit-completing-read-function 'ivy-completing-read)
    :commands (ivy-completing-read
               ivy-completion-in-region
               swiper))
#+END_SRC
**** diff-hl
:PROPERTIES:
:header-args: :tangle no
:END:

[[https://github.com/dgutov/diff-hl][GitHub]]

This mode provides indicators at the right fringe of the Emacs buffer. These
indications show where a file has been edited from the last Git commit.

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :bind (:package diff-hl
           :map diff-hl-mode-map
           ("<left-fringe> <mouse-1>" . diff-hl-diff-goto-hunk))
    :hook ((prog-mode . diff-hl-mode)
	   (vc-dir-mode . diff-hl-mode)
	   (dired-mode . diff-hl-dir-mode)
	   (magit-post-refresh . diff-hl-magit-post-refresh)
	   (org-mode . diff-hl-mode)))
#+END_SRC

**** dtrt-indent

[[https://github.com/jscheid/dtrt-indent][GitHub]]

This mode will try to 

#+BEGIN_SRC emacs-lisp
  (use-package dtrt-indent
    :delight
    :hook (prog-mode . dtrt-indent-mode))
#+END_SRC

**** Emacs shell

Emacs shell provides . Run eshell by typing =C-c e= or =M-x eshell=.

#+BEGIN_SRC emacs-lisp
  (use-package eshell
    :ensure nil
    :bind (("C-c M-t" . eshell)
           ("C-c x" . eshell)
           ("C-c e" . eshell))
    :hook (;; (eshell-first-time-mode-hook . eshell-read-history)
           (eshell-first-time-mode-hook . eshell-initialize))
    :preface
(defvar eshell-isearch-map
    (let ((map (copy-keymap isearch-mode-map)))
      (define-key map [(control ?m)] 'eshell-isearch-return)
      (define-key map [return]       'eshell-isearch-return)
      (define-key map [(control ?r)] 'eshell-isearch-repeat-backward)
      (define-key map [(control ?s)] 'eshell-isearch-repeat-forward)
      (define-key map [(control ?g)] 'eshell-isearch-abort)
      (define-key map [backspace]    'eshell-isearch-delete-char)
      (define-key map [delete]       'eshell-isearch-delete-char)
      map)
    "Keymap used in isearch in Eshell.")
    (defun eshell-initialize ()
    (defun eshell-spawn-external-command (beg end)
      "Parse and expand any history references in current input."
      (save-excursion
        (goto-char end)
        (when (looking-back "&!" beg)
          (delete-region (match-beginning 0) (match-end 0))
          (goto-char beg)
          (insert "spawn "))))

    (add-hook 'eshell-expand-input-functions 'eshell-spawn-external-command)
(use-package em-unix
      :defer t
      :config
      (unintern 'eshell/su nil)
      (unintern 'eshell/sudo nil))
      )
    (defun pcomplete/sudo ()
      (let ((prec (pcomplete-arg 'last -1)))
    (cond ((string= "sudo" prec)
      (while (pcomplete-here*
        (funcall pcomplete-command-completion-function)
        (pcomplete-arg 'last) t))))))
    :config
    (use-package em-rebind
      :ensure nil
      :demand
      :config
      ;; TODO move this back to customize
      (setq eshell-rebind-keys-alist
            '(([(control 97)] . eshell-bol)
              ([home] . eshell-bol)
              ([(control 100)] . eshell-delchar-or-maybe-eof)
              ([backspace] . eshell-delete-backward-char)
              ([delete] . eshell-delete-backward-char)
              ([(control 119)] . backward-kill-word)
              ([(control 117)] . eshell-kill-input)
              ([tab] . completion-at-point)
              ([(control 101)] . (lambda ()
                (interactive) (end-of-line)))))

      ;; TODO move this back to customize
      (setq eshell-modules-list
            '(eshell-alias
              eshell-basic
              eshell-cmpl
              eshell-dirs
              eshell-glob
              eshell-hist
              eshell-ls
              eshell-pred
              eshell-prompt
              eshell-rebind
              eshell-script
              eshell-term
              eshell-tramp
              eshell-unix
              eshell-xtra))))
#+END_SRC

***** esh-help

#+BEGIN_SRC emacs-lisp
  (use-package esh-help
    :hook (eshell-mode .
      (lambda ()
	  (autoload 'esh-help-eldoc-command "esh-help")
	  (setq-local eldoc-documentation-function
	              'esh-help-eldoc-command))))
#+END_SRC

***** em-dired

#+BEGIN_SRC emacs-lisp
  (autoload 'em-dired-new "em-dired")
  (use-package em-dired
    :ensure nil
    :bind (:package dired
		    :map dired-mode-map
		    ("e" . em-dired))
    :hook (eshell-mode . em-dired-mode)
    :init
    (advice-add 'eshell :before 'em-dired-new))
#+END_SRC

**** ESUP

[[https://github.com/jschaf/esup][GitHub]]

emacs-init-time gives good readings for Emacs startup time. Currently my
emacs-init-time is 4.5 seconds. It fluctuates based on what’s been enabled
but I aim to never let it go above 5. This is good but it includes some
things we don’t have control over (window system & Emacs C internals).

ESUP provides good info on what is taking a long time during startup. ESUP is a
startup profiler for Emacs. I’ve provided "startup-profile" so that you can just
profile what is in "default.el" (this script) & not any other miscellaneous
scripts you have around. This will be part of our effort to get quick startup
times. Slowdowns happen for various reasons but right now autorevert,
apropospriate, & flycheck are the biggest offenders.

#+BEGIN_SRC emacs-lisp
  (use-package esup
    :commands esup
    :preface
    (defun startup-profile ()
      (interactive)
      (esup (locate-library "default"))))
#+END_SRC

**** Flycheck

[[http://www.flycheck.org/][Website]]

Flycheck will annotate code with errors from the compiler or interpreter. It
supports many languages and give us a lot of features right out of the box.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :hook (prog-mode . flycheck-mode))
  (use-package flycheck-haskell
    :hook (flycheck-mode . flycheck-haskell-setup)
    )
#+END_SRC

**** github-clone
#+BEGIN_SRC emacs-lisp
  (use-package github-clone
    :disabled
    :if (locate-file "git" exec-path)
    :bind ("C-c g c" . github-clone))
#+END_SRC
**** Gnus

[[http://www.gnus.org][Website]]

Gnus is an infamous email client & news reader.

#+BEGIN_SRC emacs-lisp
  (use-package gnus
    :ensure nil
    :commands gnus
    :hook ((dired-mode . turn-on-gnus-dired-mode)))
#+END_SRC

**** God Mode

[[https://github.com/chrisdone/god-mode][GitHub]]

God Mode makes it easier to type Emacs shortcuts involving lots of modifier
keys. Activate it by pressing Escape (Notice “God” at the bottom of the screen).
You no longer have to press & hold the control key!

Note that god-mode overwrites escape key. This can cause some issues for
certain Emacs keybinds.

#+BEGIN_SRC emacs-lisp
  (use-package god-mode
    :bind (("<escape>" . god-local-mode)
;;           ("ESC" . god-local-mode)
))
#+END_SRC

**** helpful
:PROPERTIES:
:header-args: :tangle no
:END:

#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :if (>= emacs-major-version 25)
    :bind (([remap describe-function] . helpful-callable)
	   ([remap describe-variable] . helpful-variable)
	   ([remap describe-key] . helpful-key))
           ("H-h" . helpful-at-point))
#+END_SRC

**** Hippie Expand

Hippie provides dynamic expansions. Try it out by pressing =M-/=.

#+BEGIN_SRC emacs-lisp
  (use-package hippie-exp
    :ensure nil
    :bind* (("M-/" . hippie-expand)
	    ("s-?" . hippie-expand-line))
    :hook ((emacs-lisp-mode ielm-mode) .
	   (lambda ()
	     (setq-local
              hippie-expand-try-functions-list
	      (append '(try-complete-lisp-symbol-partially
	                try-complete-lisp-symbol)
	       hippie-expand-try-functions-list)))))
#+END_SRC

**** Magit

[[https://magit.vc][Website]]

Magit is a Git porcelain for Emacs. All of the features from the Git command
line are available in an intuitive Emacs buffer.

#+BEGIN_SRC emacs-lisp
  (use-package git-commit
    :hook ((git-commit-mode . flyspell-mode)
	   (git-commit-mode . git-commit-save-message)
	   (git-commit-mode . turn-on-auto-fill)))
  (use-package magit
    :preface
    (autoload 'magit-toplevel "magit")
    (autoload 'magit-read-string-ns "magit")
    (autoload 'magit-get "magit")
    (autoload 'magit-define-popup-action "magit")
    (autoload 'magit-remote-arguments "magit")
    (defun magit-dired-other-window ()
      (interactive)
      (dired-other-window (magit-toplevel)))

    (defun magit-remote-github (username &optional args)
      (interactive (list (magit-read-string-ns "User name")
			 (magit-remote-arguments)))
      (let* ((url (magit-get "remote.origin.url"))
	     (match (string-match
		     "^\\(?:https?://github\.com/\\|git@github.com:\\|ssh://git@github\.com/\\)[^/]*/\\(.*\\)"
		     url)))
	(unless match
	  (error "Not a github remote"))
	(let ((repo (match-string 1 url)))
	  (apply 'magit-remote-add username
		 (format "ssh://git@github.com/%s/%s"
			 username repo) args))))
    :hook (magit-mode . (lambda ()
			  (magit-define-popup-action
			    'magit-remote-popup
			    ?g
			    "Add remote from github user name"
			    'magit-remote-github)))
    :commands magit-clone
    :if (locate-file "git" exec-path)
    :bind (("C-x g" . magit-status)
	   ("C-x G" . magit-dispatch-popup)
	   :package magit
	   :map magit-mode-map
	   ("C-o" . magit-dired-other-window)))
#+END_SRC

***** magithub
:PROPERTIES:
:header-args: :tangle no
:END:

#+BEGIN_SRC emacs-lisp
(use-package magithub
  :after magit
  :config
  (magithub-feature-autoinject t)
  (setq magithub-clone-default-directory "~/github"))
#+END_SRC

**** MMM Mode

[[https://github.com/purcell/mmm-mode][GitHub]]

MMM mode lets you edit multiple languages within one buffer.

#+BEGIN_SRC emacs-lisp
  (use-package mmm-mode
    :commands mmm-mode
    :config
    (use-package mmm-auto
      :ensure nil))
#+END_SRC

**** multiple-cursors
[[https://github.com/magnars/multiple-cursors.el][GitHub]]

Multiple cursors give you more cursors. It is bound to =C->= & =C-<=.

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :bind
    (("<C-S-down>" . mc/mark-next-like-this)
     ("<C-S-up>" . mc/mark-previous-like-this)
     ("C->" . mc/mark-next-like-this)
     ("C-<" . mc/mark-previous-like-this)
     ("M-<mouse-1>" . mc/add-cursor-on-click)
     ("C-c C-<"	    . mc/mark-all-like-this)
     ("C-!"	    . mc/mark-next-symbol-like-this)
     ("C-S-c C-S-c" . mc/edit-lines)))
#+END_SRC

**** notmuch

#+BEGIN_SRC emacs-lisp
  (use-package notmuch
    :bind (("s-m" . notmuch)
           ("H-m" . notmuch)))
#+END_SRC

**** Org

[[https://orgmode.org][Website]]

Org mode is an impressive suite of text editing solutions. It gives you an
outliner but also much much more.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure org-plus-contrib
    :hook ((message-mode . turn-on-orgstruct++)
	   (org-mode . (lambda ()
             (add-hook 'completion-at-point-functions
	               'pcomplete-completions-at-point
                       nil t)))
	   (org-mode . auto-fill-mode)
	   (org-mode . (lambda () (setq-local scroll-margin 3)))
	   (message-mode . turn-on-orgtbl)
	   (org-mode . (lambda ()
	     (autoload 'org-eldoc-documentation-function "esh-help")
	     (setq-local eldoc-documentation-function
	                 'org-eldoc-documentation-function))))
    :bind* (("C-c c" . org-capture)
	    ("C-c a" . org-agenda)
	    ("C-c l" . org-store-link)
	    ("C-c b" . org-iswitchb))
    :config
    (use-package ob-dot
      :ensure nil
      :demand)
    (use-package ox-latex
      :ensure nil
      :demand)
    (use-package ox-beamer
      :ensure nil
      :demand)
    (use-package ox-md
      :ensure nil
      :demand))
  (use-package org-download
    :hook (dired-mode . org-download-enable))
#+END_SRC
**** Projectile

[[https://github.com/bbatsov/projectile][GitHub]]

Setup projectile & link it with some other packages. This also adds an
easymenu to make the "Projectile" modeline clickable.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :commands projectile-mode
    :bind-keymap* (("C-c p" . projectile-command-map)
		   ("s-p" . projectile-command-map))
    :bind (("C-c C-f" . projectile-find-file))
    :preface
    (autoload 'projectile-project-vcs "projectile")
    (autoload 'projectile-project-root "projectile")
    (autoload 'easy-menu-define "easymenu" "" nil 'macro)
    :demand
    :config
    (projectile-mode))
#+END_SRC

**** smart-hungry-delete

[[https://github.com/hrehfeld/emacs-smart-hungry-delete][GitHub]]

Smart hungry delete automatically delete lots of whitespace in a row.

#+BEGIN_SRC emacs-lisp
  (use-package smart-hungry-delete
    :if (>= emacs-major-version 25)
    :bind (:map prog-mode-map
           ("<backspace>" .
            smart-hungry-delete-backward-char)
	   ("C-d" .
            smart-hungry-delete-forward-char))
    :hook ((prog-mode .
            smart-hungry-delete-default-prog-mode-hook)
	   (c-mode-common .
            smart-hungry-delete-default-c-mode-common-hook)
	   (python-mode .
            smart-hungry-delete-default-c-mode-common-hook)
	   (text-mode .
            smart-hungry-delete-default-text-mode-hook)))
#+END_SRC

**** Smartparens

[[https://github.com/Fuco1/smartparens][Website]]

Smartparens is helpful in closing parenthesis when editing Lisp code.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :preface
    (autoload 'sp-with-modes "smartparens" "" nil 'macro)
    (autoload 'sp-local-pair "smartparens")
    (autoload 'sp-local-tag  "smartparens")
    :hook (((emacs-lisp-mode
             inferior-emacs-lisp-mode
             ielm-mode
             lisp-mode
             inferior-lisp-mode
             lisp-interaction-mode
             slime-repl-mode
             eval-expression-minibuffer-setup) .
            smartparens-strict-mode)
           ((emacs-lisp-mode
             inferior-emacs-lisp-mode
             ielm-mode
             lisp-mode
             inferior-lisp-mode
             lisp-interaction-mode
             slime-repl-mode
             org-mode) . show-smartparens-mode)
           ((web-mode
             nxml-mode
             html-mode) . smartparens-mode)
           (smartparens-mode . sp-use-paredit-bindings))
    :config
    (use-package smartparens-config
      :ensure nil
      :demand)

    (sp-with-modes 'org-mode
      (sp-local-pair "*" "*"
        :actions '(insert wrap)
        :unless '(sp-point-after-word-p sp-point-at-bol-p)
        :wrap "C-*" :skip-match 'sp--org-skip-asterisk)
      (sp-local-pair "_" "_" :unless '(sp-point-after-word-p)
                             :wrap "C-_")
      (sp-local-pair "/" "/" :unless '(sp-point-after-word-p)
                     :post-handlers '(("[d1]" "SPC")))
      (sp-local-pair "~" "~" :unless '(sp-point-after-word-p)
                     :post-handlers '(("[d1]" "SPC")))
      (sp-local-pair "=" "=" :unless '(sp-point-after-word-p)
                     :post-handlers '(("[d1]" "SPC")))
      (sp-local-pair "«" "»"))

    (sp-with-modes '(java-mode c++-mode)
      (sp-local-pair "{" nil
                     :post-handlers '(("||\n[i]" "RET")))
      (sp-local-pair "/*" "*/"
                     :post-handlers '((" | " "SPC")
                                      ("* ||\n[i]" "RET"))))

    (sp-with-modes '(markdown-mode gfm-mode rst-mode)
      (sp-local-pair "*" "*" :bind "C-*")
      (sp-local-tag "2" "**" "**")
      (sp-local-tag "s" "```scheme" "```")
      (sp-local-tag "<"	 "<_>" "</_>"
                    :transform 'sp-match-sgml-tags))

    (sp-local-pair 'emacs-lisp-mode "`" nil
                   :when '(sp-in-string-p))
    (sp-local-pair 'clojure-mode "`" "`"
                   :when '(sp-in-string-p))
    (sp-local-pair 'minibuffer-inactive-mode "'" nil
                   :actions nil)

    (sp-with-modes 'nix-mode
      (sp-local-pair "'" "'"
                     :unless '(sp-in-comment-p
                               sp-in-string-quotes-p))
      (sp-local-pair "\"" "\"")
      (sp-local-pair "''" "''"
                     :unless '(sp-in-comment-p
                               sp-in-string-quotes-p))))
#+END_SRC

**** sudo-edit

[[https://github.com/nflath/sudo-edit][GitHub]]

Sudo-edit lets you open a file using sudo (it actually goes through TRAMP to
achieve this).

#+BEGIN_SRC emacs-lisp
  (use-package sudo-edit
    :bind (("C-c C-r" . sudo-edit)))
#+END_SRC

**** try
[[https://github.com/larstvei/Try][GitHub]]

#+BEGIN_SRC emacs-lisp
  (use-package try
    :commands try)
#+END_SRC

**** which-key

Which-key will tell you what key bindings are available give a prefix. Test it
out by pressing =C-x= & waiting a few seconds. Each key listed is bound to a
function.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :demand
    :commands which-key-mode
    :config (which-key-mode 1))
#+END_SRC

*** Built-ins

These are available automatically, so these =use-package= blocks just
configure them.

**** ansi-color

Get color/ansi codes in compilation mode.

#+BEGIN_SRC emacs-lisp
  (use-package ansi-color
    :ensure nil
    :hook (compilation-filter . colorize-compilation-buffer)
    :preface
    (autoload 'ansi-color-apply-on-region "ansi-color")
    (defun colorize-compilation-buffer ()
      (let ((inhibit-read-only t))
	(ansi-color-apply-on-region (point-min) (point-max)))))
#+END_SRC

**** autorevert

#+BEGIN_SRC emacs-lisp
  (use-package autorevert
    :ensure nil
    :commands global-auto-revert-mode
    :demand
    :config (global-auto-revert-mode t))
#+END_SRC

**** bug-reference

#+BEGIN_SRC emacs-lisp
  (use-package bug-reference
    :ensure nil
    :hook ((prog-mode . bug-reference-prog-mode)
	   (text-mode . bug-reference-mode)))
#+END_SRC

***** bug-reference-github

#+BEGIN_SRC emacs-lisp
  (use-package bug-reference-github
    :commands bug-reference-github-set-url-format
    :preface
    (defun bug-reference-github-projectile ()
      (when (and projectile-mode
                 (eq (projectile-project-vcs
                       (projectile-project-root))
                     'git))
	(bug-reference-github-set-url-format)))
    :hook (magit-mode . bug-reference-github-projectile))
#+END_SRC

**** comint

#+BEGIN_SRC emacs-lisp
  (use-package comint
    :ensure nil
    :preface
    (autoload 'comint-write-input-ring "comint")
    (autoload 'comint-read-input-ring "comint")
    (defun turn-on-comint-history (history-file)
      (setq comint-input-ring-file-name history-file)
      (comint-read-input-ring 'silent))
    (defun save-history ()
      (dolist (buffer (buffer-list))
	(with-current-buffer buffer
                             (comint-write-input-ring)))))
#+END_SRC

**** compile

#+BEGIN_SRC emacs-lisp
  (use-package compile
    :ensure nil
    :bind (("C-c C-c" . compile)
	   :map compilation-mode-map
	   ("o" . compile-goto-error))
    :preface
    (autoload 'ansi-color-process-output "ansi-color")
    (defun show-compilation ()
      (interactive)
      (let ((compile-buf
	     (catch 'found
	       (dolist (buf (buffer-list))
		 (if (string-match "\\*compilation\\*"
                                   (buffer-name buf))
		     (throw 'found buf))))))
	(if compile-buf
	    (switch-to-buffer-other-window compile-buf)
	  (call-interactively 'compile))))

    (defun compilation-ansi-color-process-output ()
      (ansi-color-process-output nil)
      (set (make-local-variable 'comint-last-output-start)
	   (point-marker)))
    :hook (compilation-filter .
           compilation-ansi-color-process-output))
#+END_SRC

**** delsel

#+BEGIN_SRC emacs-lisp
  (use-package delsel
    :ensure nil
    :demand
    :commands delete-selection-mode
    :config (delete-selection-mode t))
#+END_SRC

**** TODO desktop
**** dired

#+BEGIN_SRC emacs-lisp
  (use-package dired
    :ensure nil
    :preface
    (autoload 'dired-get-filename "dired")
    (autoload 'term-set-escape-char "term")
    (defun dired-run-command (&optional filename)
      "Run file at point in a new buffer."
      (interactive)
      (unless filename
	(setq filename (expand-file-name
			(dired-get-filename t t)
			default-directory)))
      (let ((buffer (make-term
                      (file-name-nondirectory filename)
                      filename))
	    (buffer-read-only nil))
	(with-current-buffer buffer
	  ;; (term-mode)
	  (term-char-mode)
	  (term-set-escape-char ?\C-x))
	(set-process-sentinel
          (get-buffer-process buffer)
	  (lambda (proc event)
	     (when (not (process-live-p proc))
	       (kill-buffer (process-buffer proc)))))
	(switch-to-buffer buffer)))
    :bind (("C-c J" . dired-double-jump)
	   :package dired
	   :map dired-mode-map
	   ("C-c C-c" . compile)
	   ("r" . term)
	   ("M-@" . shell)
	   ("M-*" . eshell)
	   ("W" . browse-url-of-dired-file)
	   ("@" . dired-run-command)))
  (use-package dired-du
    :commands dired-du-mode)
#+END_SRC

***** dired-column

#+BEGIN_SRC emacs-lisp
  (use-package dired-column
    :ensure nil
    :bind (:package dired
		    :map dired-mode-map
		    ("o" . dired-column-find-file)))
#+END_SRC

***** dired-subtree

#+BEGIN_SRC emacs-lisp
  (use-package dired-subtree
    :bind (:package dired
		    :map dired-mode-map
		    ("<tab>" . dired-subtree-toggle)
		    ("TAB" . dired-subtree-toggle)
		    ("<backtab>" . dired-subtree-cycle)))
#+END_SRC

***** dired-x

#+BEGIN_SRC emacs-lisp
  (use-package dired-x
    :ensure nil
    :hook ((dired-mode . dired-omit-mode)
	   (dired-mode . dired-hide-details-mode))
    :bind (("s-\\" . dired-jump-other-window)
	   :package dired
	   :map dired-mode-map
	   (")" . dired-omit-mode)))
#+END_SRC

**** eldoc

Provides some info for the thing at the point.

#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :ensure nil
    :hook ((emacs-lisp-mode . eldoc-mode)
	   (eval-expression-minibuffer-setup . eldoc-mode)
	   (lisp-mode-interactive-mode . eldoc-mode)
	   (typescript-mode . eldoc-mode)
	   (haskell-mode . eldoc-mode)
	   (python-mode . eldoc-mode)
	   (eshell-mode . eldoc-mode)
	   (org-mode . eldoc-mode)))
#+END_SRC

**** electric

Setup these modes:

     - electric-quote
     - electric-indent
     - electric-layout

#+BEGIN_SRC emacs-lisp
  (use-package electric
    :ensure nil
    :if (>= emacs-major-version 25)
    :hook ((prog-mode . electric-quote-local-mode)
	   (text-mode . electric-quote-local-mode)
	   (org-mode . electric-quote-local-mode)
           (message-mode . electric-quote-local-mode)
	   (prog-mode . electric-indent-local-mode)
	   (prog-mode . electric-layout-mode)))
#+END_SRC

***** elec-pair

Setup electric-pair-mode for prog-modes. Also disable it when smartparens is
setup.

#+BEGIN_SRC emacs-lisp
  (use-package elec-pair
    :ensure nil
    :if (>= emacs-major-version 25)
    :hook
     ((prog-mode . electric-pair-local-mode)
      (smartparens-mode . (lambda ()
        (electric-pair-local-mode -1)))))
#+END_SRC

**** eww
#+BEGIN_SRC emacs-lisp
  (use-package eww
    :ensure nil
    :if (and (not window-system)
             (not (string-equal
                    (getenv "TERM_PROGRAM")
                    "Apple_Terminal")))
    :commands eww-browse-url
    :init
    (setq browse-url-browser-function 'eww-browse-url))
#+END_SRC
**** executable

#+BEGIN_SRC emacs-lisp
  (use-package executable
    :ensure nil
    :hook
    ((after-save .
      executable-make-buffer-file-executable-if-script-p)))
#+END_SRC

**** ffap

#+BEGIN_SRC emacs-lisp
  (use-package ffap
    :bind (("C-x C-f" . find-file-at-point)
	   ("C-x 4 C-f" . ffap-other-window)
	   ("C-x C-r" . ffap-read-only)
	   ("C-x C-v" . ffap-alternate-file)
	   ("C-x 4 f" . ffap-other-window)
	   ("C-x 5 f" . ffap-other-frame)
	   ("C-x 4 r" . ffap-read-only-other-window)
	   ("C-x 5 r" . ffap-read-only-other-frame)
	   ("C-x d"  . dired-at-point)
	   ("C-x 4 d" . ffap-dired-other-window)
	   ("C-x 5 d" . ffap-dired-other-frame)
	   ("C-x C-d" . ffap-list-directory))
    :hook ((gnus-summary-mode . ffap-gnus-hook)
	   (gnus-article-mode . ffap-gnus-hook)
	   (vm-mode . ffap-ro-mode-hook)
	   (rmail-mode . ffap-ro-mode-hook))
    :ensure nil)
#+END_SRC
**** files

#+BEGIN_SRC emacs-lisp
  (use-package files
    :ensure nil
    :demand
    :preface
    (defun find-file--line-number (orig-fun filename
                                   &optional wildcards)
      (save-match-data
	(let* ((matched (string-match
                          "^\\(.*\\):\\([0-9]+\\):?$"
                          filename))
	       (line-number (and matched
                              (match-string 2 filename)
			      (string-to-number
                                (match-string 2 filename))))
	       (filename (if matched
                             (match-string 1 filename)
                             filename)))
	  (apply orig-fun (list filename wildcards))
	  (when line-number
	    ;; goto-line is for interactive use
	    (goto-char (point-min))
	    (forward-line (1- line-number))))))
    :config
    (advice-add 'find-file
                :around #'find-file--line-number))
#+END_SRC

**** flyspell

#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :ensure nil
    :if (locate-file
	 (if (boundp 'ispell-program-name)
             ispell-program-name "ispell")
	 exec-path)
    :hook ((text-mode . flyspell-mode)
	   (prog-mode . flyspell-prog-mode))
    :bind (:map flyspell-mode-map
		("C-M-i" . nil)))
#+END_SRC

**** goto-addr

#+BEGIN_SRC emacs-lisp
  (use-package goto-addr
    :ensure nil
    :hook ((prog-mode . goto-address-prog-mode)
	   (git-commit-mode . goto-address-mode)
           (shell-mode . goto-address-mode)))
#+END_SRC

**** hl-line
#+BEGIN_SRC emacs-lisp
  (use-package hl-line
    :ensure nil
    :hook ((prog-mode . hl-line-mode)
	   (org-mode . hl-line-mode)
	   (dired-mode . hl-line-mode)))
#+END_SRC
**** paren

#+BEGIN_SRC emacs-lisp
  (use-package paren
    :ensure nil
    :hook ((prog-mode . show-paren-mode)
	   (prog-mode . (lambda () (show-paren-mode -1)))))
#+END_SRC

**** pp

#+BEGIN_SRC emacs-lisp
  (use-package pp
    :ensure nil
    :commands pp-eval-last-sexp
    :bind (([remap eval-expression] . pp-eval-expression))
    ;; :init
    ;;(global-unset-key (kbd "C-x C-e"))
    :hook ((lisp-mode emacs-lisp-mode) . always-eval-sexp)
    :preface
    (defun always-eval-sexp ()
      (define-key (current-local-map)
                  (kbd "C-x C-e")
                  'pp-eval-last-sexp)))
#+END_SRC

**** prog-mode

#+BEGIN_SRC emacs-lisp
  (use-package prog-mode
    :ensure nil
    :hook ((prog-mode . prettify-symbols-mode)
	   (lisp-mode . prettify-symbols-lisp)
	   (c-mode . prettify-symbols-c)
	   (c++-mode . prettify-symbols-c++)
	   ((js-mode js2-mode) . prettify-symbols-js)
	   (prog-mode . (lambda ()
             (setq-local scroll-margin 3))))
    :preface
    (defun prettify-symbols-prog ()
      (push '("<=" . ?≤) prettify-symbols-alist)
      (push '(">=" . ?≥) prettify-symbols-alist))
    (defun prettify-symbols-lisp ()
      (push '("/=" . ?≠) prettify-symbols-alist)
      (push '("sqrt" . ?√) prettify-symbols-alist)
      (push '("not" . ?¬) prettify-symbols-alist)
      (push '("and" . ?∧) prettify-symbols-alist)
      (push '("or" . ?∨) prettify-symbols-alist))
    (defun prettify-symbols-c ()
      (push '("<=" . ?≤) prettify-symbols-alist)
      (push '(">=" . ?≥) prettify-symbols-alist)
      (push '("!=" . ?≠) prettify-symbols-alist)
      (push '("&&" . ?∧) prettify-symbols-alist)
      (push '("||" . ?∨) prettify-symbols-alist)
      (push '(">>" . ?») prettify-symbols-alist)
      (push '("<<" . ?«) prettify-symbols-alist))
    (defun prettify-symbols-c++ ()
      (push '("<=" . ?≤) prettify-symbols-alist)
      (push '(">=" . ?≥) prettify-symbols-alist)
      (push '("!=" . ?≠) prettify-symbols-alist)
      (push '("&&" . ?∧) prettify-symbols-alist)
      (push '("||" . ?∨) prettify-symbols-alist)
      (push '(">>" . ?») prettify-symbols-alist)
      (push '("<<" . ?«) prettify-symbols-alist)
      (push '("->" . ?→) prettify-symbols-alist))
    (defun prettify-symbols-js ()
      (push '("function" . ?λ) prettify-symbols-alist)
      (push '("=>" . ?⇒) prettify-symbols-alist)))
#+END_SRC

**** savehist-mode

#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :ensure nil
    :hook (after-init . savehist-mode))
#+END_SRC

**** saveplace-mode

#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :ensure nil
    :if (>= emacs-major-version 25)
    :hook (after-init . save-place-mode))
#+END_SRC

**** TODO server
**** Shell

#+BEGIN_SRC emacs-lisp
  (use-package shell
    :ensure nil
    :bind (("C-c C-s" . shell)
           ("H-s" . shell))
    :hook ((shell-mode . ansi-color-for-comint-mode-on)
           (shell-mode . dirtrack-mode)
           (shell-mode . pcomplete-shell-setup)
           (shell-mode . use-histfile)
           )
    :preface
    (defun use-histfile ()
      (turn-on-comint-history
       (expand-file-name "sh-history" user-emacs-directory))))
#+END_SRC

**** simple
#+BEGIN_SRC emacs-lisp
(use-package simple
   :ensure nil
   :demand
   :commands (column-number-mode auto-fill-mode)
   :bind
   (("C-`" . list-processes)
    :map minibuffer-local-map
    ("<escape>"	 . abort-recursive-edit)
    ("M-TAB"	 . previous-complete-history-element)
    ("<M-S-tab>" . next-complete-history-element))
   :hook ((text-mode . visual-line-mode))
   :config (column-number-mode))
#+END_SRC
**** subword

#+BEGIN_SRC emacs-lisp
  (use-package subword
    :ensure nil
    :hook ((java-mode . subword-mode)))
#+END_SRC

**** term

#+BEGIN_SRC emacs-lisp
  (use-package term
    :ensure nil
    :commands (term-mode term-char-mode)
    :hook ((term-mode .
             (lambda ()
               (setq term-prompt-regexp
                     "^[^#$%>\n]*[#$%>] *")
               (setq-local transient-mark-mode nil)
               (auto-fill-mode -1))))
    :preface
    (autoload 'tramp-tramp-file-p "tramp")
    (autoload 'tramp-dissect-file-name "tramp"))

  (use-package tramp-term
    :commands tramp-term)
#+END_SRC

**** text-mode

#+BEGIN_SRC emacs-lisp
  (use-package text-mode
    :no-require
    :ensure nil
    :hook ((text-mode . turn-on-auto-fill)))
#+END_SRC

**** time

#+BEGIN_SRC emacs-lisp
  (use-package time
    :demand
    :ensure nil
    :config (display-time-mode))
#+END_SRC

**** url-handlers

#+BEGIN_SRC emacs-lisp
  (use-package url-handlers
    :ensure nil
    :demand
    :commands url-handler-mode
    :config (url-handler-mode))
#+END_SRC

**** which-func

#+BEGIN_SRC emacs-lisp
  (use-package which-func
    :ensure nil
    :demand
    :config (which-function-mode))
#+END_SRC
**** whitespace

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :ensure nil
    :hook (prog-mode . whitespace-mode))
#+END_SRC
**** TODO winner-mode
*** Programming languages

Each =use-package= declaration corresponds to =major modes= in Emacs lingo.
Each language will at least one of these major modes as well as associated
packages (for completion, syntax checking, etc.)

**** TODO Agda
**** C/C++

#+BEGIN_SRC emacs-lisp
  (use-package cc-mode
    :ensure nil
    :mode (("\\.h\\(h?\\|xx\\|pp\\)\\'" . c++-mode)
	   ("\\.m\\'" . c-mode)
	   ("\\.c\\'" . c-mode)
	   ("\\.cpp\\'" . c++-mode)
	   ("\\.c++\\'" . c++-mode)
	   ("\\.mm\\'" . c++-mode)))
#+END_SRC

***** Irony
:PROPERTIES:
:header-args: :tangle no
:END:

#+BEGIN_SRC emacs-lisp
  (use-package irony
    :preface
    (autoload 'file-remote-p "files")
    (defun irony-mode-disable-remote ()
      "Disabled irony in remote buffers."
      (when (and buffer-file-name
                 (file-remote-p buffer-file-name))
	(irony-mode -1)))
    :hook (((c++-mode c-mode objc-mode) .
            irony-mode-disable-remote)
           ((c++-mode c-mode objc-mode) . irony-mode)))
  (use-package irony-cdb
    :ensure nil
    :hook (irony-mode . irony-cdb-autosetup-compile-options))
 #+END_SRC

****** flycheck-irony

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-irony
    :hook (flycheck-mode . flycheck-irony-setup))
#+END_SRC

****** irony-eldoc

#+BEGIN_SRC emacs-lisp
  (use-package irony-eldoc
    :hook (irony-mode . irony-eldoc))
#+END_SRC

**** CoffeeScript

#+BEGIN_SRC emacs-lisp
  (use-package coffee-mode
    :mode (("\\.coffee\\'" . coffee-mode)))
#+END_SRC

**** CSS

#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :ensure nil
    :mode "\\.css\\'")
#+END_SRC

**** CSV

#+BEGIN_SRC emacs-lisp
  (use-package csv-mode
    :mode "\\.csv\\'")
#+END_SRC

**** ELF

#+BEGIN_SRC emacs-lisp
  (use-package elf-mode
    :magic ("ELF" . elf-mode))
#+END_SRC

**** Emacs speaks statistics

[[https://ess.r-project.org][Website]]

#+BEGIN_SRC emacs-lisp
  (use-package ess-site
    :ensure ess
    :no-require
    :interpreter (("Rscript" . r-mode)
		  ("r" . r-mode))
    :mode (("\\.sp\\'"		. S-mode)
	   ("/R/.*\\.q\\'"	. R-mode)
	   ("\\.[qsS]\\'"	. S-mode)
	   ("\\.ssc\\'"		. S-mode)
	   ("\\.SSC\\'"		. S-mode)
	   ("\\.[rR]\\'"	. R-mode)
	   ("\\.[rR]nw\\'"	. Rnw-mode)
	   ("\\.[sS]nw\\'"	. Snw-mode)
	   ("\\.[rR]profile\\'" . R-mode)
	   ("NAMESPACE\\'"	. R-mode)
	   ("CITATION\\'"	. R-mode)
	   ("\\.omg\\'"		. omegahat-mode)
	   ("\\.hat\\'"		. omegahat-mode)
	   ("\\.lsp\\'"		. XLS-mode)
	   ("\\.do\\'"		. STA-mode)
	   ("\\.ado\\'"		. STA-mode)
	   ("\\.[Ss][Aa][Ss]\\'"	. SAS-mode)
	   ("\\.[Ss]t\\'"	. S-transcript-mode)
	   ("\\.Sout"		. S-transcript-mode)
	   ("\\.[Rr]out"	. R-transcript-mode)
	   ("\\.Rd\\'"		. Rd-mode)
	   ("\\.[Bb][Uu][Gg]\\'"	 . ess-bugs-mode)
	   ("\\.[Bb][Oo][Gg]\\'"	 . ess-bugs-mode)
	   ("\\.[Bb][Mm][Dd]\\'"	 . ess-bugs-mode)
	   ("\\.[Jj][Aa][Gg]\\'"	 . ess-jags-mode)
	   ("\\.[Jj][Oo][Gg]\\'"	 . ess-jags-mode)
	   ("\\.[Jj][Mm][Dd]\\'"	 . ess-jags-mode)
	   ))
#+END_SRC

**** Go

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :mode "\\.go\\'")
#+END_SRC

**** HAML

#+BEGIN_SRC emacs-lisp
  (use-package haml-mode
    :mode "\\.haml\\'")
#+END_SRC

**** Haskell
***** ghc
:PROPERTIES:
:header-args: :tangle no
:END:

Note: this needs ghc-mod to be in PATH to work properly.

#+BEGIN_SRC emacs-lisp
  (use-package ghc
    :if (locate-file "ghc-mod" exec-path)
    :hook ((haskell-mode . ghc-init)
	   (haskell-mode . ghc-comp-init)))
#+END_SRC
***** haskell-mode

#+BEGIN_SRC emacs-lisp
  (load "haskell-mode-autoloads" t t)
  (use-package haskell
    :ensure haskell-mode
    :mode (("\\.hs\\'" . haskell-mode)
	   ("\\.cabal\\'" . haskell-cabal-mode))
    :hook ((haskell-mode . subword-mode)
	   (haskell-mode . flyspell-prog-mode)
	   (haskell-mode . haskell-indentation-mode)
	   ;; (haskell-mode . haskell-indent-mode)
	   (haskell-mode . imenu-add-menubar-index)
	   (haskell-mode .
			 (lambda ()
			   (autoload 'haskell-doc-current-info
			     "haskell-doc")
			   (setq-local eldoc-documentation-function
				       'haskell-doc-current-info))))
    :init
    (add-to-list 'completion-ignored-extensions ".hi"))
#+END_SRC

***** haskell-interactive-mode
#+BEGIN_SRC emacs-lisp
  (use-package haskell-interactive-mode
    :ensure nil
    :hook (haskell-mode . interactive-haskell-mode))
#+END_SRC

**** Java
***** jdee

#+BEGIN_SRC emacs-lisp
  (use-package jdee
    :mode ("\\.java\\'" . jdee-mode)
    :bind (:package jdee
           :map jdee-mode-map
           ("<s-mouse-1>" . jdee-open-class-at-event)))
#+END_SRC

**** JavaScript
***** indium
:PROPERTIES:
:header-args: :tangle no
:END:

#+BEGIN_SRC emacs-lisp
  (use-package indium
    :if (>= emacs-major-version 25)
    :mode ("\\.js\\'" . indium-mode))
#+END_SRC

***** js2-mode
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :mode (("\\.js\\'" . js2-mode)
	   ("\\.es6\\'" . js2-mode)
	   ("\\.ejs\\'" . js2-mode))
    :interpreter "node")
  (use-package js2-imenu-extras
    :ensure nil
    :hook (js2-mode . js2-imenu-extras-mode))
#+END_SRC

***** tern

#+BEGIN_SRC emacs-lisp
  (use-package tern
    :hook (js2-mode . tern-mode))
#+END_SRC

**** JSON

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :mode (("\\.bowerrc$"     . json-mode)
	   ("\\.jshintrc$"    . json-mode)
	   ("\\.json_schema$" . json-mode)
	   ("\\.json\\'" . json-mode))
    :bind (:package json-mode-map
	   :map json-mode-map
           ("C-c <tab>" . json-mode-beautify))
    :config
    (make-local-variable 'js-indent-level))
#+END_SRC

**** LaTeX
***** auctex

Auctex provides some helpful tools for working with LaTeX.

#+BEGIN_SRC emacs-lisp
  (use-package tex-site
    :ensure auctex
    :no-require
    :mode ("\\.tex\\'" . TeX-latex-mode))
  (use-package tex-mode
    :ensure nil
    :hook (TeX-mode . latex-electric-env-pair-mode))
#+END_SRC

**** Lisp

#+BEGIN_SRC emacs-lisp
  (use-package elisp-mode
    :ensure nil
    :interpreter (("emacs" . emacs-lisp-mode)))
#+END_SRC

***** ielm

#+BEGIN_SRC emacs-lisp
  (use-package ielm
    :ensure nil
    :bind ("C-c :" . ielm))
#+END_SRC

**** Mach-O

#+BEGIN_SRC emacs-lisp
  (use-package macho-mode
    :ensure nil
    :magic (("\xFE\xED\xFA\xCE" . macho-mode)
	    ("\xFE\xED\xFA\xCF" . macho-mode)
	    ("\xCE\xFA\xED\xFE" . macho-mode)
	    ("\xCF\xFA\xED\xFE" . macho-mode)))
#+END_SRC

**** Markdown
***** markdown-mode

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'"       . markdown-mode)
           ("\\.markdown\\'" . gfm-mode)))
#+END_SRC

**** git-modes

#+BEGIN_SRC emacs-lisp
  (use-package gitattributes-mode
    :mode (("/\\.gitattributes\\'"  . gitattributes-mode)
	   ("/info/attributes\\'"   . gitattributes-mode)
	   ("/git/attributes\\'"    . gitattributes-mode)))
  (use-package gitconfig-mode
    :mode (("/\\.gitconfig\\'"      . gitconfig-mode)
	   ("/\\.git/config\\'"     . gitconfig-mode)
	   ("/modules/.*/config\\'" . gitconfig-mode)
	   ("/git/config\\'"        . gitconfig-mode)
	   ("/\\.gitmodules\\'"     . gitconfig-mode)
	   ("/etc/gitconfig\\'"     . gitconfig-mode)))
  (use-package gitignore-mode
    :mode (("/\\.gitignore\\'"      . gitignore-mode)
	   ("/info/exclude\\'"      . gitignore-mode)
	   ("/git/ignore\\'"        . gitignore-mode)))
#+END_SRC

**** restclient

#+BEGIN_SRC emacs-lisp
  (use-package restclient
    :mode (("\\.rest\\'" . restclient-mode)
	   ("\\.restclient\\'" . restclient-mode)))
#+END_SRC

**** Nix

#+BEGIN_SRC emacs-lisp
  (use-package nix-mode
    :mode "\\.nix\\'")
  (use-package nix-drv-mode
    :ensure nil
    :mode "\\.drv\\'")
  (use-package nix-shell
    :ensure nil
    :commands (nix-shell nix-unpack))
#+END_SRC

***** nix-buffer

#+BEGIN_SRC emacs-lisp
  (use-package nix-buffer
    :commands nix-buffer
    ;; :preface
    ;; (defun turn-on-nix-buffer ()
    ;;   (when (and (not noninteractive)
    ;;	       (not (eq (aref (buffer-name) 0) ?\s))
    ;;	       (not (file-remote-p default-directory)))
    ;;     (nix-buffer)))
    ;; :hook (after-change-major-mode . turn-on-nix-buffer)
    )
#+END_SRC
***** nix-update
#+BEGIN_SRC emacs-lisp
(use-package nix-update
  :commands nix-update-fetch
  :ensure nil
  :bind (("C-. u" . nix-update-fetch)))
#+END_SRC
**** mwim

[[https://github.com/alezost/mwim.el][GitHub]]

#+BEGIN_SRC emacs-lisp
  (use-package mwim
    :bind (([remap move-beginning-of-line]
            . mwim-beginning-of-code-or-line)
           ([remap move-end-of-line]
            . mwim-end-of-code-or-line)))
#+END_SRC

**** PHP

#+BEGIN_SRC emacs-lisp
  (use-package php-mode
    :mode "\\.php\\'")
#+END_SRC

**** Proof General
:PROPERTIES:
:header-args: :tangle no
:END:

[[https://proofgeneral.github.io][Website]]

#+BEGIN_SRC emacs-lisp
  (use-package proof-site
    :ensure proofgeneral
    :demand
    :if (not needs-package-init))
#+END_SRC

**** Python

***** Anaconda

#+BEGIN_SRC emacs-lisp
  (use-package anaconda-mode
    :hook ((python-mode . anaconda-mode)
	   (python-mode . anaconda-eldoc-mode)))
#+END_SRC

***** python-mode

#+BEGIN_SRC emacs-lisp
  (use-package python
    :ensure nil
    :mode ("\\.py\\'" . python-mode)
    :interpreter ("python" . python-mode))
#+END_SRC

***** jedi
:PROPERTIES:
:header-args: :tangle no
:END:
#+BEGIN_SRC emacs-lisp
  (use-package jedi
    :hook ((python-mode . jedi:setup))
    :config
    (setq jedi:complete-on-dot t))
#+END_SRC
***** elpy

#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :disabled
    :mode ("\\.py\\'" . elpy-mode))
#+END_SRC

**** Ruby

#+BEGIN_SRC emacs-lisp
  (use-package ruby-mode
    :ensure nil
    :mode ("\\.rb\\'" . ruby-mode)
    :interpreter ("ruby" . ruby-mode))
#+END_SRC

**** Rust

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :mode "\\.rs\\'")
#+END_SRC

**** SASS

#+BEGIN_SRC emacs-lisp
  (use-package sass-mode
    :mode "\\.sass\\'")
#+END_SRC

**** Scala

#+BEGIN_SRC emacs-lisp
  (use-package scala-mode
    :interpreter ("scala" . scala-mode))
#+END_SRC

**** SCSS

#+BEGIN_SRC emacs-lisp
  (use-package scss-mode
    :mode "\\.scss\\'")
#+END_SRC

**** Shell

#+BEGIN_SRC emacs-lisp
(use-package sh-script
  :ensure nil
  :commands shell-command
  :mode (("\\.*shellrc$" . sh-mode)
	 ("\\.*shell_profile" . sh-mode)
	 ("\\.zsh\\'" . sh-mode)))
#+END_SRC

**** texinfo

#+BEGIN_SRC emacs-lisp
  (use-package texinfo
    :ensure nil
    :mode ("\\.texi\\'" . texinfo-mode))
#+END_SRC

**** TypeScript

#+BEGIN_SRC emacs-lisp
  (use-package typescript-mode
    :mode "\\.ts\\'")
#+END_SRC

***** tide

#+BEGIN_SRC emacs-lisp
  (use-package tide
    :disabled
    :hook ((typescript-mode . tide-setup)
	   (typescript-mode . tide-hl-identifier-mode)))
#+END_SRC

**** Web

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :mode (("\\.erb\\'" . web-mode)
	   ("\\.mustache\\'" . web-mode)
	   ("\\.html?\\'" . web-mode)
	   ("\\.php\\'" . web-mode)
	   ("\\.jsp\\'" . web-mode)
	   ;; ("\\.jsx?$" . web-mode)
	   ("\\.es6\\'" . web-mode)
	   ("\\.ejs\\'" . web-mode)
	   ("\\.phtml\\'" . web-mode)
	   ("\\.tpl\\.php\\'" . web-mode)
	   ("\\.[agj]sp\\'" . web-mode)
	   ("\\.as[cp]x\\'" . web-mode)
	   ("\\.djhtml\\'" . web-mode)))
#+END_SRC

**** YAML

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode "\\.ya?ml\\'")
#+END_SRC

*** Custom

These are all available in [[./site-lisp][./site-lisp]]. Eventually they should go into separate
repositories.

**** dired-column
**** em-dired
**** installer
**** macho-mode
**** nethack

#+BEGIN_SRC emacs-lisp
  (use-package nethack
    :commands nethack
    :ensure nil)
#+END_SRC

**** nix-fontify
**** set-defaults
**** use-package-list
*** Other

These should correspond to minor modes or helper functions. Some of them are
more helpful than others but none are /essential/.

Most of these are available in MELPA.

**** browse-at-remote
#+BEGIN_SRC emacs-lisp
  (use-package browse-at-remote
    :bind ("C-c g g" . browse-at-remote))
#+END_SRC
**** buffer-move
[[https://github.com/lukhas/buffer-move][GitHub]]

#+BEGIN_SRC emacs-lisp
  (use-package buffer-move
    :bind
    (("<M-S-up>" . buf-move-up)
     ("<M-S-down>" . buf-move-down)
     ("<M-S-left>" . buf-move-left)
     ("<M-S-right>" . buf-move-right)))
#+END_SRC

**** copy-as-format

#+BEGIN_SRC emacs-lisp
  (use-package copy-as-format
    :bind (("C-c w s" . copy-as-format-slack)
	   ("C-c w g" . copy-as-format-github)))
#+END_SRC

**** crux

#+BEGIN_SRC emacs-lisp
  (use-package crux
    :bind (("C-c D" . crux-delete-file-and-buffer)
	   ("C-c C-e" . crux-eval-and-replace)
           ("C-c d" . crux-duplicate-current-line-or-region)
	   ([shift return] . crux-smart-open-line)))
#+END_SRC

**** delight



#+BEGIN_SRC emacs-lisp
  (use-package delight)
#+END_SRC
**** dumb-jump
#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :if (>= emacs-major-version 25)
    :hook ((prog-mode . dumb-jump-mode)))
#+END_SRC
**** TODO emacs-gif-screencast
**** TODO epresent
**** expand-region

#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :hook ((prog-mode . dumb-jump-mode)))
#+END_SRC

**** TODO eyebrowse
**** git-attr
:PROPERTIES:
:header-args: :tangle no
:END:
#+BEGIN_SRC emacs-lisp
  (use-package git-attr-linguist
    :ensure git-attr
    :hook ((find-file . git-attr-linguist)))
#+END_SRC
**** TODO hackernews
**** htmlize

#+BEGIN_SRC emacs-lisp
  (use-package htmlize :no-require)
#+END_SRC

**** TODO idle-highlight-mode
**** TODO iedit
**** page-break-lines

#+BEGIN_SRC emacs-lisp
  (use-package page-break-lines
    :delight
    :hook ((doc-mode
	    emacs-lisp-mode
	    compilation-mode
	    outline-mode
	    prog-mode
	    haskell-mode
	    help-mode
	    magit-mode) . page-break-lines-mode))
#+END_SRC

**** pandoc-mode

#+BEGIN_SRC emacs-lisp
  (use-package pandoc-mode
    :hook ((markdown-mode . pandoc-mode)
	   (pandoc-mode . pandoc-load-default-settings)))
#+END_SRC

**** rainbow-delimiters

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook ((emacs-lisp-mode
	    inferior-emacs-lisp-mode
	    ielm-mode
	    lisp-mode
	    inferior-lisp-mode
	    lisp-interaction-mode
	    slime-repl-mode) . rainbow-delimiters-mode))
#+END_SRC

**** rainbow-mode

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :hook ((emacs-lisp-mode
	    inferior-emacs-lisp-mode
	    ielm-mode
	    lisp-mode
	    inferior-lisp-mode
	    lisp-interaction-mode
	    slime-repl-mode
	    web-mode
	    less-css-mode
	    html-mode
	    css-mode) . rainbow-mode))
#+END_SRC

**** shrink-whitespace

#+BEGIN_SRC emacs-lisp
  (use-package shrink-whitespace
    :bind ("H-SPC" . shrink-whitespace))
#+END_SRC

**** TODO smex
**** string-inflection

#+BEGIN_SRC emacs-lisp
  (use-package string-inflection
    :bind (("C-c r r" . string-inflection-all-cycle)
	   ("C-c r c" . string-inflection-camelcase)
	   ("C-c r l" . string-inflection-lower-camelcase)
	   ("C-c r u" . string-inflection-underscore)
	   ("C-c r k" . string-inflection-kebab-case)
	   ("C-c r J" . string-inflection-java-style-cycle)))
#+END_SRC

**** TODO sx
**** TODO twittering-mode
**** TODO undo-tree
**** TODO unfill
**** volatile-highlights
:PROPERTIES:
:header-args: :tangle no
:END:
#+BEGIN_SRC emacs-lisp
  (use-package volatile-highlights
    :commands volatile-highlights-mode
    :config (volatile-highlights-mode t)
    :delight
    :demand)
#+END_SRC
**** TODO yasnippet
**** TODO git-timemachine
**** with-editor
#+BEGIN_SRC emacs-lisp
  (use-package with-editor
    :disabled
    :hook
    ((shell-mode eshell-mode) . with-editor-export-editor))
#+END_SRC
**** TODO flycheck-pkg-config
**** TODO dired-rsync
**** TODO org-brain
**** comment-tags
#+BEGIN_SRC emacs-lisp
(use-package comment-tags
  :hook (prog-mode . comment-tags-mode))
#+END_SRC
**** unfill
#+BEGIN_SRC emacs-lisp
(use-package unfill
  :bind ([remap fill-paragraph] . unfill-toggle))
#+END_SRC

**** misc
#+BEGIN_SRC emacs-lisp
  (use-package ripgrep :commands ripgrep-regexp)
  (use-package rg :commands rg-dwim)
  (use-package org-static-blog :commands org-static-blog)
  (use-package pcmpl-args)
  (use-package pcmpl-git)
  (use-package pcomplete
    :ensure nil
    :hook ((shell-mode . (lambda () (pcomplete-comint-setup 'shell-dynamic-complete-functions)))
           (term-mode . (lambda () (pcomplete-comint-setup 'term-dynamic-complete-functions))))
    )
#+END_SRC
* Profiles
:PROPERTIES:
:CUSTOM_ID: profiles
:END:

All of these files live outside of Emacs but are necessary for a usable
developer environment. They are basic shell profile and some git configuration
scripts as well.

** =.profile=
:PROPERTIES:
:header-args: :tangle profile.sh :tangle-mode (identity #o755)
:END:

To use this, you must create a short ~/.profile file. Here is an example,

#+BEGIN_SRC shell :tangle no
bootstrap=$HOME/.nix-profile/etc/profile
[ -f $bootstrap ] && source $bootstrap
#+END_SRC

Run fortune,

#+BEGIN_SRC shell
if [ -z "$FORTUNE" ]; then
  @fortune@/bin/fortune
  export FORTUNE=1
fi
#+END_SRC

Here we setup =.profile=. First, setup exports.

#+BEGIN_SRC shell :padline no
  export LANG=en_US.UTF-8 \
         LC_ALL=en_US.UTF-8 \
         PATH=@PATH@:$PREFIX/bin
         INFOPATH=@INFOPATH@ \
         MANPATH=@MANPATH@ \
         XDG_DATA_DIRS=@XDG_DATA_DIRS@ \
         CVS_RSH=ssh \
         HISTFILE=$HOME/.history \
         SAVEHIST=10000 \
         HISTSIZE=10000
#+END_SRC

Then setup aliases.

#+BEGIN_SRC shell
alias ls="TERM=ansi ls --color=always" \
      l="ls -lF" \
      ..="cd .." \
      ...="cd ../.." \
      ....="cd ../../.." \
      .....="cd ../../../.." \
      tree='tree -Csuh' \
      grep="grep --color=auto"
#+END_SRC

Configure INSIDE_EMACS.

#+BEGIN_SRC shell
if [ "$TERM" = dumb ] && ! [ -z "$INSIDE_EMACS" ]; then
    export TERM=dumb-emacs-ansi \
	   COLORTERM=1
fi
#+END_SRC

Define =update_terminal_cwd= function.

#+BEGIN_SRC shell
update_terminal_cwd () {
    local SEARCH=' '
    local REPLACE='%20'
    local PWD_URL="file://$HOSTNAME${PWD//$SEARCH/$REPLACE}"
    printf '\e]7;%s\a' "$PWD_URL"
}
#+END_SRC
** =.zshrc=
:PROPERTIES:
:header-args: :tangle zshrc.sh :tangle-mode (identity #o755)
:CUSTOM_ID: zshrc
:END:

This is a profile for use with [[http://www.zsh.org][Zsh]]. It is closely based off of [[https://github.com/robbyrussell/oh-my-zsh][oh-my-zsh]].

Setup ZSH profile. First, we just source the global profile.

#+BEGIN_SRC shell :padline no
source @out@/etc/profile
#+END_SRC

Handle dumb options.

#+BEGIN_SRC shell
case "$TERM" in
    dumb)
	unsetopt zle \
		 prompt_cr \
		 prompt_subst
	if whence -w precmd >/dev/null; then
	    unfunction precmd
	fi
	if whence -w preexec >/dev/null; then
	    unfunction preexec
	fi
	PS1='$ '
	return
	;;
esac
#+END_SRC

Load up site-functions in ZSH.

#+BEGIN_SRC shell
fpath+=@completions@/share/zsh/site-functions
#+END_SRC

Turn on ZSH-specific options.

#+BEGIN_SRC shell
setopt always_to_end \
       append_history \
       auto_cd \
       auto_menu \
       auto_name_dirs \
       auto_pushd \
       cdablevarS \
       extended_glob \
       hist_expire_dups_first \
       hist_find_no_dups \
       hist_ignore_dups \
       hist_ignore_space \
       hist_reduce_blanks \
       hist_verify \
       interactive_comments \
       long_list_jobs \
       multios \
       no_beep \
       prompt_subst \
       pushd_ignore_dups \
       pushdminus \
       transient_rprompt \
       menu_complete
#+END_SRC

Setup completions & colors.

#+BEGIN_SRC shell
autoload -U colors && colors
autoload -U compinit && compinit
#+END_SRC

Bind to emacs...

#+BEGIN_SRC
bindkey -e
#+END_SRC

Zstyle completions.

#+BEGIN_SRC shell
zstyle ':completion:*::::' completer \
       _expand _complete _ignored _approximate
zstyle ':completion:*' menu select=1 \
       _complete _ignored _approximate
zstyle ':completion:*' matcher-list \
       'm:{a-zA-Z-_}={A-Za-z_-}' \
       'r:|=*' 'l:|=* r:|=*'
zstyle ':completion:*' list-colors ''
zstyle ':completion:*' select-prompt \
       '%SScrolling active: current selection at %p%s'
zstyle ':completion:*' \
       ignored-patterns '*~' '_*' '*\\\#*\\\#'
zstyle ':completion:*:scp:*' group-order files \
       all-files users hosts-domain \
       hosts-host hosts-ipaddr
zstyle ':completion:*:ssh:*' group-order hosts-domain \
       hosts-host users hosts-ipaddr
zstyle ':vcs_info:*' enable git
zstyle '*' single-ignored show
#+END_SRC

Turn on prompt with colors.

#+begin_SRC shell
PROMPT='%F{blue}%n@%m:%F{cyan}%c%F{yellow} $ %F{reset}'
#+END_SRC

Setup Apple Terminal so that CWD is shown.

#+BEGIN_SRC shell
if [ "$TERM_PROGRAM" = Apple_Terminal ] \
   && [ -z "$INSIDE_EMACS" ]; then
    autoload add-zsh-hook
    add-zsh-hook chpwd update_terminal_cwd
    update_terminal_cwd
fi
#+END_SRC

** =etc-profile.sh=
:PROPERTIES:
:header-args: :tangle etc-profile.sh :tangle-mode (identity #o755)
:END:

This just sources everything in the =/etc/profile.d= dir. =PREFIX= can be
used to reference the Nix output dir.

#+BEGIN_SRC shell :padline no
export PREFIX=@out@
#+END_SRC

This will source everything in =/etc/profile.d=.

#+BEGIN_SRC shell
if [ -d @out@/etc/profile.d ]; then
  for i in @out@/etc/profile.d/*.sh; do
    if [ -r $i ]; then
      source $i
    fi
  done
fi
#+END_SRC
** =.gitignore=
:PROPERTIES:
:header-args: :tangle gitignore
:END:

Some basic gitignore paths.

#+BEGIN_SRC gitignore :padline no
*~
\#*\#
*.DS_Store
#+END_SRC
** =.gitconfig=
:PROPERTIES:
:header-args: :tangle gitconfig
:END:

#+BEGIN_SRC gitconfig :padline no
[core]
	editor = emacsclient
#	fsmonitor = @out@/etc/fsmonitor

[commit]
	gpgSign = true

[push]
	default = simple

[pull]
	rebase = true

[alias]
	amend = commit --amend

[help]
	autcorrect = 1

[color]
	ui = true
#+END_SRC
* Bootstrapping
:PROPERTIES:
:CUSTOM_ID: bootstrap
:END:

** =site-paths.el.in=
:PROPERTIES:
:header-args: :tangle site-paths.el.in :comments link
:CUSTOM_ID: site-paths
:END:

This file provides site-specific paths. However, it must be substituted in Nix
before we can actually run it in Emacs. To prevent Emacs from trying to run
this, I’ve set the syntax to =text=.

#+BEGIN_SRC emacs-lisp
(require 'set-defaults)
(require 'subr-x)
#+END_SRC

=output-directory= points to the nix-profile directory created by Nix.
Ideally, this could point to a Nix store path, but the order of building
means that we don’t know this until too late.

#+BEGIN_SRC emacs-lisp
(defvar output-directory
        (expand-file-name ".nix-profile" (getenv "HOME")))
(defvar zsh-command
        (expand-file-name "bin/zsh" output-directory))
#+END_SRC

Setup =exec-path=.

#+BEGIN_SRC emacs-lisp
(setq exec-path
      (append `("@bins@/bin"
                ,(expand-file-name "bin" output-directory)
		"@PATH@")
              exec-path))
#+END_SRC

Setup =man-path=.

#+BEGIN_SRC emacs-lisp
(defvar man-path `("@manpages@/share/man"
                   ,(expand-file-name "share/man" output-directory)
		   "@MANPATH@"))
#+END_SRC

This will setup cacert-file var,

#+BEGIN_SRC emacs-lisp
(defcustom cacert-file "/etc/ssl/certs/ca-bundle.crt"
  "Path for SSL certificates."
  :type 'string
  :group 'environment)
#+END_SRC

Set env vars provided by Nix,

#+BEGIN_SRC emacs-lisp
  (append-envs ":"
   '("NIX_PATH"
       ("nixpkgs=/nix/var/nix/profiles/per-user/root/channels/nixpkgs"
	"nixos=/nix/var/nix/profiles/per-user/root/channels/nixos"))
   `("PATH" ,exec-path)
   `("MANPATH" ,man-path))
  (set-envs
   `("NIX_REMOTE" "daemon")
   `("HISTFILE" ,(expand-file-name ".history" (getenv "HOME"))))
#+END_SRC

Set paths provided by Nix,

#+BEGIN_SRC emacs-lisp
  (defvar gnutls "gnutls")
  (defvar pdf2dsc-command "pdf2dsc")
  (defvar dvips-command "dvips")
  (defvar dvipng-command "dvipng")
  (defvar xetex-command "xetex")
  (defvar xelatex-command "xelatex")
  (defvar luatex-command "luatex")
  (defvar makeinfo-command "makeinfo")
  (defvar LaTeX-command "LaTeX")
  (defvar pdftex-command "pdftex")
  (defvar context-command "context")
  (defvar bibtex-command "bibtex")
  (defvar makeindex-command "makeindex")
  (defvar dvipdfmx-command "dvipdfmx")
  (defvar ag-executable "ag")
  (defvar ripgrep-executable "ripgrep")
  (defvar lacheck-command "lacheck")
  (defvar chktex-command "chktex")
  (defvar ps2pdf-command "ps2pdf")

  (set-paths
   '(company-cmake-executable "@cmake@/bin/cmake")
   '(doc-view-dvipdf-program "@ghostscript@/bin/dvipdf")
   '(cacert-file "@cacert@/etc/ssl/certs/ca-bundle.crt")
   '(calc-gnuplot-name "@gnuplot@/bin/gnuplot")
   '(gnuplot-program "@gnuplot@/bin/gnuplot")
   '(doc-view-ps2pdf-program "@ghostscript@/bin/ps2pdf")
   '(dired-touch-program "@coreutils@/bin/touch")
   '(dired-chmod-program "@coreutils@/bin/chmod")
   '(dired-chown-program "@coreutils@/bin/chown")
   '(dired-free-space-program "@coreutils@/bin/df")
   '(diff-command "@diffutils@/bin/diff")
   '(find-program "@findutils@/bin/find")
   '(epg-gpg-program "@gpg@/bin/gpg")
   '(epg-gpgconf-program "@gpg@/bin/gpgconf")
   '(epg-gpgsm-program "@gpg@/bin/gpgsm")
   '(flycheck-sh-bash-executable "@bash@/bin/bash")
   '(flycheck-sh-zsh-executable "@zsh@/bin/zsh")
   '(flycheck-perl-executable "@perl@/bin/perl")
   ;; '(flycheck-go-golint-executable "@golint@/bin/golint")
   '(flycheck-haskell-hlint-executable "@hlint@/bin/hlint")
   '(flycheck-python-flake8-executable "@flake8@/bin/flake8")
   '(flycheck-asciidoc-executable "@asciidoc@/bin/asciidoc")
   '(flycheck-less-executable "@lessc@/bin/lessc")
   '(flycheck-c/c++-gcc-executable "@gcc@/bin/gcc")
   '(flycheck-javascript-eslint-executable "@eslint@/bin/eslint")
   '(flycheck-javascript-jshint-executable "@jshint@/bin/jshint")
   ;; '(flycheck-go-build-executable "@go@/bin/go")
   ;; '(flycheck-go-test-executable "@go@/bin/go")
   '(flycheck-lua-executable "@lua@/bin/luac")
   '(flycheck-xml-xmllint-executable "@libxml2@/bin/xmllint")
   '(flycheck-html-tidy-executable "@tidy@/bin/tidy")
   '(fortune-dir "@fortune@/share/games/fortunes")
   '(fortune-program "@fortune@/bin/fortune")
   '(fortune-file "@fortune@/share/games/fortunes/debian")
   '(grep-program "@gnugrep@/bin/grep")
   '(haskell-check-command "@hlint@/bin/hlint")
   '(haskell-hoogle-command "@hoogle@/bin/hoogle")
   '(haskell-hasktags-path "@hasktags@/bin/hasktags")
   '(ispell-program-name "@aspell@/bin/aspell")
   '(ispell-grep-command "@gnugrep@/bin/grep")
   '(irony-cmake-executable "@cmake@/bin/cmake")
   '(jka-compr-info-compress-program "@ncompress@/bin/compress")
   '(jka-compr-info-uncompress-program "@ncompress@/bin/uncompress")
   ;; '(irony-server-install-prefix "@irony@")
   '(jka-compr-dd-program "@coreutils@/bin/dd")
   '(magit-git-executable "@git@/bin/git")
   '(markdown-command "@markdown2@/bin/markdown2")
   '(manual-program "@man@/bin/man")
   '(man-awk-command "@gawk@/bin/awk")
   '(man-sed-command "@gnused@/bin/sed")
   '(man-untabify-command "@coreutils@/bin/pr")
   '(nethack-executable "@nethack@/bin/nethack")
   '(org-pandoc-command "@pandoc@/bin/pandoc")
   '(pandoc-binary "@pandoc@/bin/pandoc")
   '(remote-shell-program "@openssh@/bin/ssh")
   '(ripgrep-executable "@ripgrep@/bin/rg")
   '(rtags-path "@rtags@/bin")
   '(sql-ingres-program "@parallel@/bin/sql")
   '(sql-interbase-program "@unixODBC@/bin/isql")
   ;; '(sql-mysql-program "@mariadb@/bin/mysql")
   '(sql-ms-program "@freetds@/bin/osql")
   '(sql-postgres-program "@freetds@/bin/osql")
   '(sql-sqlite-program "@sqliteInteractive@/bin/sqlite3")
   '(tramp-encoding-shell "@bash@/bin/sh")
   '(tex-shell "@bash@/bin/sh")
   '(xargs-program "@findutils@/bin/xargs")
   '(vc-git-program "@git@/bin/git")
   '(gnutls "@gnutls@/bin/gnutls-cli")
   '(pdf2dsc-command "@ghostscript@/bin/pdf2dsc")
   '(preview-gs-command "@texlive@/bin/rungs")
   '(TeX-command "@texlive@/bin/tex")
   '(LaTeX-command "@texlive@/bin/latex")
   '(latex-run-command "@texlive@/bin/latex")
   '(tex-run-command "@texlive@/bin/tex")
   '(luatex-command "@texlive@/bin/luatex")
   '(xetex-command "@texlive@/bin/xetex")
   '(xelatex-command "@texlive@/bin/xelatex")
   '(makeinfo-command "@texinfoInteractive@/bin/makeinfo")
   '(pdftex-command "@texlive@/bin/pdftex")
   '(context-command "@texlive@/bin/context")
   '(bibtex-command "@texlive@/bin/bibtex")
   '(dvipdfmx-command "@texlive@/bin/dvipdfmx")
   '(makeindex-command "@texlive@/bin/makeindex")
   '(chktex-command "@texlive@/bin/chktex")
   '(lacheck-command "@texlive@/bin/lacheck")
   '(dvipdfmx-command "@texlive@/bin/dvipdfmx")
   '(dvips-command "@texlive@/bin/dvips")
   '(dvipng-command "@texlive@/bin/dvipng")
   '(ps2pdf-command "@ghostscript@/bin/ps2pdf")
   '(locate-executable "@findutils@/bin/locate")
   '(ag-executable "@ag@/bin/ag")
   '(notmuch-command "@notmuch@/bin/notmuch")
   '(dumb-jump-rg-cmd "@ripgrep@/bin/rg")
   '(dumb-jump-ag-cmd "@ag@/bin/ag")
   '(gud-gdb-command-name "@gdb@/bin/gdb")
   '(coq-prog-name "@coq@/bin/coqtop")
   '(coq-dependency-analyzer "@coq@/bin/coqdep")
   '(coq-compiler "@coq@/bin/coqc")
   )
#+END_SRC

Set some defaults that depend on the path variables below,

#+BEGIN_SRC emacs-lisp
  (set-defaults
   '(imap-ssl-program `(,(concat gnutls " --tofu -p %p %s")))
   '(tls-program (concat gnutls " --tofu -p %p %h"))
   '(preview-pdf2dsc-command
     (concat pdf2dsc-command " %s.pdf %m/preview.dsc"))
   '(preview-dvips-command
     (concat dvips-command " -Pwww %d -o %m/preview.ps"))
   '(preview-fast-dvips-command
     (concat dvips-command " -Pwww %d -o %m/preview.ps"))
   '(preview-dvipng-command
     (concat dvipng-command
       " -picky -noghostscript %d -o \"%m/prev%%03d.png\""))
   '(TeX-engine-alist
     `((xetex "XeTeX"
        xetex-command
        xelatex-command
        xetex-command)
       (luatex "LuaTeX" luatex-command
        ,(concat luatex-command " --jobname=%s")
        luatex-command)))
   '(TeX-command-list
     `(("TeX"
	,(concat "%(PDF)%(tex) %(file-line-error) "
	         "%(extraopts) %`%S%(PDFout)%(mode)%' %t")
	TeX-run-TeX nil
	(plain-tex-mode ams-tex-mode texinfo-mode)
	:help "Run plain TeX")
       ("LaTeX" "%`%l%(mode)%' %t" TeX-run-TeX nil
	(latex-mode doctex-mode)
	:help "Run LaTeX")
       ("Makeinfo" ,(concat makeinfo-command
                            " %(extraopts) %t")
	TeX-run-compile nil
	(texinfo-mode)
	:help "Run Makeinfo with Info output")
       ("Makeinfo HTML"
        ,(concat makeinfo-command
                 " %(extraopts) --html %t")
	TeX-run-compile nil
	(texinfo-mode)
	:help "Run Makeinfo with HTML output")
       ("AmSTeX"
	,(concat pdftex-command
             " %(PDFout) %(extraopts) %`%S%(mode)%' %t")
	TeX-run-TeX nil
	(ams-tex-mode)
	:help "Run AMSTeX")
       ("ConTeXt"
	,(concat context-command
             " --once --texutil %(extraopts) %(execopts)%t")
	TeX-run-TeX nil
	(context-mode)
	:help "Run ConTeXt once")
       ("ConTeXt Full"
        ,(concat context-command
                 " %(extraopts) %(execopts)%t")
	TeX-run-TeX nil
	(context-mode)
	:help "Run ConTeXt until completion")
       ("BibTeX" ,(concat bibtex-command " %s")
	TeX-run-BibTeX nil t :help "Run BibTeX")
       ("Biber" "biber %s" TeX-run-Biber nil t
                :help "Run Biber")
       ("View" "%V" TeX-run-discard-or-function t t
               :help "Run Viewer")
       ("Print" "%p" TeX-run-command t t
               :help "Print the file")
       ("Queue" "%q" TeX-run-background nil t
               :help "View the printer queue"
               :visible TeX-queue-command)
       ("File" ,(concat dvips-command " %d -o %f ")
        TeX-run-dvips t t :help "Generate PostScript file")
       ("Dvips" ,(concat dvips-command " %d -o %f ")
        TeX-run-dvips nil t
        :help "Convert DVI file to PostScript")
       ("Dvipdfmx" ,(concat dvipdfmx-command " %d")
        TeX-run-dvipdfmx nil t
        :help "Convert DVI file to PDF with dvipdfmx")
       ("Ps2pdf" ,(concat ps2pdf-command " %f")
        TeX-run-ps2pdf nil t
        :help "Convert PostScript file to PDF")
       ("Index" ,(concat makeindex-command " %s")
        TeX-run-index nil t
        :help "Run makeindex to create index file")
       ("upMendex" "upmendex %s"
        TeX-run-index t t
        :help "Run mendex to create index file")
       ("Xindy" "xindy %s"
        TeX-run-command nil t
        :help "Run xindy to create index file")
       ("Check" ,(concat lacheck-command " %s")
        TeX-run-compile nil
        (latex-mode)
        :help "Check LaTeX file for correctness")
       ("ChkTeX" ,(concat chktex-command " -v6 %s")
        TeX-run-compile nil
        (latex-mode)
        :help "Check LaTeX file for common mistakes")
       ("Spell" "(TeX-ispell-document \"\")"
        TeX-run-function nil t
        :help "Spell-check the document")
       ("Clean" "TeX-clean"
        TeX-run-function nil t
        :help "Delete generated intermediate files")
       ("Clean All" "(TeX-clean t)" TeX-run-function nil t
        :help
        "Delete generated intermediate and output files")
       ("Other" "" TeX-run-command t t
        :help "Run an arbitrary command")))
   '(counsel-grep-base-command
     (concat ripgrep-executable
      " -i -M 120 --no-heading --line-number --color never '%s' %s"))
   '(counsel-rg-base-command
     (concat ripgrep-executable
             " -i --no-heading --line-number %s ."))
   '(counsel-ag-base-command
     (concat ag-executable " --nocolor --nogroup %s"))
   '(org-preview-latex-process-alist
     `((dvipng
        :programs ("latex" "dvipng")
	    :description "dvi > png"
	    :message ""
	    :image-input-type "dvi"
	    :image-output-type "png"
	    :image-size-adjust (1.0 . 1.0)
	    :latex-compiler
        (,(concat LaTeX-command
           " -interaction nonstopmode -output-directory %o %f"))
	    :image-converter
        (,(concat dvipng-command
           " -fg %F -bg %B -D %D -T tight -o %O %f")))))
   '(Info-directory-list '("@infopages@/share/info"))
   '(tramp-remote-path
     `(tramp-own-remote-path
	   "/run/current-system/sw/bin"
	   tramp-default-remote-path
	   "/bin"
	   "/usr/bin"
	   "/sbin"
	   "/usr/sbin"
	   "/usr/local/bin"
	   "/usr/local/sbin"
	   "/opt/bin"
	   "/opt/sbin"
	   ,(expand-file-name "bin" output-directory)))
   '(woman-manpath man-path)
   '(Man-header-file-path
     `("@sysheaders@/include"
       "/usr/include"
       "/usr/local/include"))
   '(ffap-c-path
     '("@sysheaders@/include"
       "/usr/include"
       "/usr/local/include"))
   '(rng-schema-locating-files
     `("schemas.xml"
	   "@schemas@"
	   ,(expand-file-name
	      "schema/schemas.xml" data-directory)))
   '(irony-additional-clang-options
     '("-I@sysheaders@/include"
	   "-I@sysheaders@/include/c++/v1"
	   "-F@sysframeworks@/Library/Frameworks"))
   )
#+END_SRC

** =bootstrap.sh=
:PROPERTIES:
:header-args: :tangle install :shebang "#!/usr/bin/env sh"
:END:

This is the bootstrap script that is mentioned above. We use it to install the
IDE. It ensures Nix is installed as well as that the Git repo is available &
up-to-date.

First we install Nix if it isn’t already.

#+BEGIN_SRC shell
if ! command -v nix-env >/dev/null 2>&1; then
    nix_installer=$(mktemp)
    curl -s https://nixos.org/nix/install \
      > $nix_installer
    sh $nix_installer
fi
#+END_SRC

If we are in a Git repo already, we’ll pull to get latest updates.

#+BEGIN_SRC shell
if [ -d .git ] && command -v git >/dev/null 2>&1; then
    git pull origin master || true
fi
#+END_SRC

If we can’t find default.nix then we’ll clone from GitHub. This will be stored in
=~/.local/share/bauer=. 

#+BEGIN_SRC shell
if ! [ -f default.nix ] \
   && command -v git >/dev/null 2>&1; then
    repo_dir=$HOME/.local/share/bauer
    mkdir -p $(dirname $repo_dir)
    git clone https://github.com/matthewbauer/bauer \
              $repo_dir
    cd $repo_dir
fi
#+END_SRC

The last action is to install our new derivation.

#+BEGIN_SRC shell
nix-env -if .
#+END_SRC

Install the profile.

#+BEGIN_SRC shell
echo "source $HOME/.nix-profile/etc/profile" >> $HOME/.profile

echo "To use bauer correctly, you must first source the profile."
echo
echo "To do this, just run:"
echo "  source $HOME/.nix-profile/etc/profile"
echo "From you command line"
echo "You can also run either emacs or zsh to launch the environment"
#+END_SRC

** =runemacs.sh=
:PROPERTIES:
:header-args: :tangle runemacs.sh :tangle-mode (identity #o755) :shebang "#!/usr/bin/env sh"
:CUSTOM_ID: runemacs
:END:

Cross-platform script to execute app.

#+BEGIN_SRC shell :padline no
case $(uname) in
    Darwin)
	open @emacs@/Applications/Emacs.app
    ;;
    *)
	@emacs@/bin/emacs
    ;;
esac
#+END_SRC
* Building
:PROPERTIES:
:CUSTOM_ID: build
:END:

** =default.nix=: the tangler
:PROPERTIES:
:header-args: :tangle default.nix
:END:

Here we being the building process. There are a couple of stages to this not
normally seen in configurations. The first part is the ‘default.nix’ which will
tangle the README.org file. This should be the only file that has to live ouside
of this ORG document. This is meant to be very minimal so that once we tangle
README.org, we can get a working .nix file to import from using Nix’s import
from derivation.

The function header defines some arguments you can pass. It will use the latest
nixpkgs-unstable from nixos.org. If you want to change this, you can pass in
your own pkgs variable.

The small argument is a bit of a hack. Nix will only recognize args that have
been explicitly listed so we cannot rely on the ‘...’ syntax to pick up random
args.

#+BEGIN_SRC nix :padline no
# -*- mode: nix; coding: utf-8; -*-
{ channel ? "nixpkgs-unstable"
, nixpkgs-url ?
  "nixos.org/channels/${channel}/nixexprs.tar.xz"
, pkgs ? import (builtins.fetchTarball nixpkgs-url) {}
, small ? false
, ...
} @ args:
#+END_SRC

Now let's tangle README.org... This uses ORG’s babel functionality to generate a
.nix file. The .nix file is renamed to default.nix to replace this script.

#+BEGIN_SRC nix
  let
  ensure = f: n: if builtins.pathExists f then f
		 else builtins.fetchurl
		 "https://matthewbauer.us/bauer/${n}";
  in import (pkgs.runCommand "README" {
    buildInputs = with pkgs; [ emacs git ];
  } (''
    install -D ${ensure ./README.org "README.org"} \
	    $out/README.org
    cd $out
  '' + pkgs.lib.optionalString (builtins.pathExists ./site-lisp) ''
    cp -r ${./site-lisp} site-lisp
  '' + ''
    emacs --batch --quick \
	  -l ob-tangle \
    --eval "(org-babel-tangle-file \"README.org\")"
    cp bauer.nix default.nix
  '')) (args // { inherit ensure pkgs; })
#+END_SRC

** =bauer.nix=: the build script
:PROPERTIES:
:header-args: :tangle bauer.nix
:END:

Here we have the actual Nix file that will build our Emacs configuration. Again
we have some options that can be provided...

#+BEGIN_SRC nix :padline no
  # -*- mode: nix; coding: utf-8; -*-
  { pkgs ? import <nixpkgs> {}
  , ensure ? (f: n: f)
  , small ? pkgs.config.bauer.small or true
  , ... }: with pkgs; let
  big = !small;
  allowUnfree = pkgs.config.allowUnfree or false;
#+END_SRC

By default, you will be building the "small" version which is about 500MB. The
normal version has a huge closure totalling in at over 5GB. This is extremely
useful for integrations with developer tools and manuals, but also inconvenient
when wanting to start running for the first time. If you want to enable the big
version, you can just do ‘config.bauer.small = false’ in your
~/.config/nixpkgs/config.nix file.
Alternatively, if you /want/ the small version, just do
‘nixpkgs.config.bauer.small = true’.

Next we start defining some packages. R is one of the simpler ones right now,
so let's start with that.

#+BEGIN_SRC nix
  rEnv = pkgs.rWrapper.override {
    packages = with pkgs.rPackages; [
      RCurl
    ];
  };
#+END_SRC

Here we define our package set. This will just give us access to all of the
Emacs packages defined in Nixpkgs.

We also define our Emacs version to use. Mitsuharo’s Emacs package is much
better for MacOS so we use that when we’re on Darwin systems. Otherwise, just
default to ‘emacs’ which should be the latest (Nixpkgs-unstable has version 26.1
currently).

#+BEGIN_SRC nix
  customEmacsPackages = emacsPackagesNg.overrideScope
    (super: self: {
      emacs = if stdenv.isDarwin then emacsMacport else emacs;
    });
#+END_SRC

Next, we define aspell with the English language. This is used by Emacs
ispell.

#+BEGIN_SRC nix
  myAspell = aspellWithDicts (ps : with ps; [ en ]);
#+END_SRC

Tex live provides some LaTeX commads for us.

#+BEGIN_SRC nix
  myTex = texlive.combine {
    inherit (texlive) xetex setspace
      fontspec chktex enumitem xifthen
      ifmtarg filehook wrapfig inconsolata
      upquote minted lastpage collection-basic
      collection-binextra collection-context
      collection-fontsrecommended collection-fontutils
      collection-langenglish collection-latex
      collection-latexrecommended collection-luatex
      collection-metapost collection-texworks
      collection-xetex capt-of ulem hyperref titlesec;
  };
#+END_SRC

*** Emacs configuration

Here, we start building up the site-paths.el file. This does a simple
substitution of all the attributes set.

#+BEGIN_SRC nix
    site-paths = runCommand "site-paths.el" ({
      inherit (customEmacsPackages) emacs;
      inherit ripgrep ag fortune gnutls nethack
              coreutils findutils openssh
              bash zsh diffutils man gawk
              gnugrep gnused cacert

              # Nix paths
              manpages sysheaders sysframeworks
              schemas bins infopages;
      gpg = gnupg1compat;
      aspell = myAspell;
    } // (lib.optionalAttrs big {
      # random packages needed in site-paths
      inherit ant perl perlcritic
        asciidoc lessc lua gcc
        pandoc clang cmake ghostscript
        sqliteInteractive freetds
        parallel unixODBC ncompress
        texinfoInteractive notmuch gnuplot
        gdb coq rtags git # mariadb go golint
        ;
      inherit (pythonPackages) flake8;
      inherit (nodePackages) jshint eslint;
      inherit (haskellPackages) hoogle hlint; # hasktags
      texlive = myTex;
      markdown2 = pythonPackages.markdown2;
      tidy = html-tidy;
      libxml2 = libxml2.bin;
      # stylish = haskellPackages.stylish-haskell;
      # intero = haskellPackages.intero-nix-shim;
      # irony = irony-server;
      # jdeeserver = jdee-server;

      inherit MANPATH PATH;
    })) "substituteAll ${./site-paths.el.in} $out";
#+END_SRC

Emacs building can be divided into phases. Each phase will run through the Elisp
once.

**** Phase 1: picking up dependencies

myEmacsPackages gets a listing of all of the packages that are needed by the
Emacs configuration. use-package-list generates this list automatically.

#+BEGIN_SRC nix
package-list =
  runCommand "package-list" {
    buildInputs = [ customEmacsPackages.emacs ];
  } ''
#+END_SRC

#+BEGIN_SRC nix
  emacs --batch --quick \
        -L ${customEmacsPackages.use-package
            }/share/emacs/site-lisp/elpa/use-package-* \
        -L ${customEmacsPackages.delight
            }/share/emacs/site-lisp/elpa/delight-* \
        -L ${customEmacsPackages.bind-key
            }/share/emacs/site-lisp/elpa/bind-key-* \
        -l ${ensure ./site-lisp/set-defaults.el
                     "site-lisp/set-defaults.el"} \
        -l ${ensure ./site-lisp/bauer.el
                     "site-lisp/bauer.el"} \
        -l ${ensure ./site-lisp/use-package-list.el
                     "site-lisp/use-package-list.el"} \
	--eval "(use-package-list \"${./README.el}\")" \
        > $out
#+END_SRC

#+BEGIN_SRC nix
  '';
#+END_SRC

#+BEGIN_SRC nix
myEmacsPackages = builtins.fromJSON
                   (builtins.readFile package-list);
#+END_SRC

**** Phase 2: byte compiling

#+BEGIN_SRC nix
  default = runCommand "default.el" {
    buildInputs = [customEmacsPackages.emacs];
  } ''
#+END_SRC

Install our lisp files. Many of these should be released into MELPA but don’t
have the time to do it currently.

#+BEGIN_SRC nix
  install -D ${site-paths} \
          $out/share/emacs/site-lisp/site-paths.el
  install -D ${./README.el} \
          $out/share/emacs/site-lisp/default.el
  install -D ${ensure ./site-lisp/em-dired.el
                       "site-lisp/em-dired.el"} \
          $out/share/emacs/site-lisp/em-dired.el
  install -D ${ensure ./site-lisp/dired-column.el
                       "site-lisp/dired-column.el"} \
          $out/share/emacs/site-lisp/dired-column.el
  install -D ${ensure ./site-lisp/macho-mode.el
                       "site-lisp/macho-mode.el"} \
          $out/share/emacs/site-lisp/macho-mode.el
  install -D ${ensure ./site-lisp/nethack.el
                       "site-lisp/nethack.el"} \
          $out/share/emacs/site-lisp/nethack.el
  install -D ${ensure ./site-lisp/set-defaults.el
                       "site-lisp/set-defaults.el"} \
          $out/share/emacs/site-lisp/set-defaults.el
  install -D ${ensure ./site-lisp/installer.el
                       "site-lisp/installer.el"} \
          $out/share/emacs/site-lisp/installer.el
  install -D ${ensure ./site-lisp/restart-emacs.el
                       "site-lisp/restart-emacs.el"} \
          $out/share/emacs/site-lisp/restart-emacs.el
  install -D ${ensure ./site-lisp/use-package-list.el
                       "site-lisp/use-package-list.el"} \
          $out/share/emacs/site-lisp/use-package-list.el
  install -D ${ensure ./site-lisp/bauer.el
                      "site-lisp/bauer.el"} \
          $out/share/emacs/site-lisp/bauer.el
#+END_SRC

This is fairly complicated. What happens is we batch compile all of the .el
files. The problem is the .el files all are going to depend on dependencies
that we have just found in package-list. The solution is that complex eval
below where we add all of the paths (plus their requisites) to the load
path. This works but is hacky & I am interested in fixing it.

#+BEGIN_SRC nix
cd $out/share/emacs/site-lisp
export HOME=$PWD
emacs --batch --quick \
      --eval \
"(let ((default-directory \"${emacsWrapper
  ((requiredPackages customEmacsPackages myEmacsPackages)
   ++ (with customEmacsPackages; [use-package delight]))
}/share/emacs/site-lisp\"))
  (normal-top-level-add-subdirs-to-load-path))" \
      -L . -f batch-byte-compile *.el
#+END_SRC

#+BEGIN_SRC nix
  '';
#+END_SRC

**** Phase 3: wrapping into Emacs

#+BEGIN_SRC nix
  emacsWrapper = explicitRequires:
   runCommand "emacs-packages-deps"
   { inherit explicitRequires;
     inherit (xorg) lndir;
     inherit (customEmacsPackages) emacs; } ''
  findInputsOld() {
      local pkg="$1"; shift
      local var="$1"; shift
      local propagatedBuildInputsFiles=("$@")
      local varSlice="$var[*]"
      case "''${!varSlice-}" in
	  ,*" $pkg "*) return 0 ;;
      esac
      unset -v varSlice
      eval "$var"'+=("$pkg")'
      if ! [ -e "$pkg" ]; then
	  echo "build input $pkg does not exist" >&2
	  exit 1
      fi
      local file
      for file in "''${propagatedBuildInputsFiles[@]}"; do
	  file="$pkg/nix-support/$file"
	  [[ -f "$file" ]] || continue
	  local pkgNext
	  for pkgNext in $(< "$file"); do
	      findInputsOld "$pkgNext" "$var" \
			    "''${propagatedBuildInputsFiles[@]}"
	  done
      done
  }
  mkdir -p $out/bin
  mkdir -p $out/share/emacs/site-lisp
  local requires
  for pkg in $explicitRequires; do
    findInputsOld $pkg requires propagated-user-env-packages
  done
  linkPath() {
    local pkg=$1
    local origin_path=$2
    local dest_path=$3
    if [[ -d "$pkg/$origin_path" ]]; then
      $lndir/bin/lndir -silent "$pkg/$origin_path" \
                               "$out/$dest_path"
    fi
  }
  linkEmacsPackage() {
    linkPath "$1" "bin" "bin"
    linkPath "$1" "share/emacs/site-lisp" \
                  "share/emacs/site-lisp"
  }
  for pkg in "''${requires[@]}"; do
    linkEmacsPackage $pkg
  done
  $emacs/bin/emacs --batch \
                   -f batch-byte-compile \
                   "$siteStart"
  '';
#+END_SRC

requiredPackages is a function that takes two arguments.

#+BEGIN_SRC nix
requiredPackages = epkgs: map (x:
  if builtins.hasAttr x epkgs
    then builtins.getAttr x epkgs
  else if builtins.hasAttr x emacsPackages
    then builtins.getAttr x emacsPackages
  else abort "no attribute found for use-package ${x}");
#+END_SRC

Now we build our Emacs distribution.

TODO use dump-emacs here to speed up config.

#+BEGIN_SRC nix
  myEmacs = customEmacsPackages.emacsWithPackages (epkgs:
    (requiredPackages epkgs myEmacsPackages)
    ++ [default epkgs.use-package]
  );
#+END_SRC

*** The environment

Finally, we can actually build the environment.

First build the info pages...

#+BEGIN_SRC nix
  infopages = buildEnv {
    name = "info-pages";
    paths = userPackages ++ [customEmacsPackages.emacs];
    extraOutputsToInstall = [ "info" "doc" "devdoc" ];
    pathsToLink = [ "/share/info" ];
    postBuild = ''
      shopt -s nullglob
      for i in $out/share/info/*; do
        ${texinfoInteractive}/bin/install-info \
               $i $out/share/info/dir
      done
    '';
  };
#+END_SRC

Setup man pages...

#+BEGIN_SRC nix
  manpages = buildEnv {
    name = "man-pages";
    ignoreCollisions = (!(config.bauer.small or false));
    paths = userPackages ++ [posix_man_pages
			     # llvmPackages.clang-manpages
			     # llvmPackages.llvm-manpages
			     ]
      ++ stdenv.lib.optional (stdenv.isDarwin && big && allowUnfree)
			     "${apple_sdk}/usr"
      ++ stdenv.lib.optional stdenv.isLinux man-pages;
    extraOutputsToInstall = [ "man" "doc" "devdoc" "devman" ];
    pathsToLink = [ "/share/man" ];
  };
#+END_SRC

Setup XDG data directory..

#+BEGIN_SRC nix
  xdg-data = buildEnv {
    name = "xdg-data-dirs";
    paths = userPackages ++ [ customEmacsPackages.emacs zsh ];
    pathsToLink = [
      "/share/applications"
      "/share/mime"
      "/share/menus"
      "/share/icons"
    ];
    postBuild = ''
      export XDG_DATA_DIRS=$out/share

      if [ -w $out/share/applications ]; then
        ${desktop-file-utils}/bin/update-desktop-database \
                                  $out/share/applications
      fi

      if [ -w $out/share/mime ] \
         && [ -w $out/share/mime/packages ]; then
        ${shared-mime-info}/bin/update-mime-database \
                                -V $out/share/mime
      fi
    '';
  };
#+END_SRC

ZSH completions...

#+BEGIN_SRC nix
  zsh-completions = buildEnv {
    name = "zsh-completions";
    paths = userPackages;
    pathsToLink = [ "/share/zsh/site-functions" ];
  };
#+END_SRC

Setup binaries

#+BEGIN_SRC nix
  bins = buildEnv {
    name = "bins";
    paths = userPackages;
    extraOutputsToInstall = [ "bin" ];
    pathsToLink = [ "/bin" ];
    postBuild = ''
      find $out/bin -maxdepth 1 -name ".*" -type l -delete
    '';
  };
#+END_SRC

Setup system headers...

#+BEGIN_SRC nix
  sysheaders = buildEnv {
    name = "headers";
    paths = [ libcxx ]
      ++ stdenv.lib.optional (stdenv.isDarwin && big && allowUnfree)
                              "${apple_sdk}/usr";
  };
#+END_SRC

Setup some Apple frameworks.

#+BEGIN_SRC nix
  apple_sdk = "${darwin.xcode}/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk";
  sysframeworks = buildEnv {
    name = "frameworks";
    paths = stdenv.lib.optionals (stdenv.isDarwin && big && allowUnfree)
            [ "${apple_sdk}/System/Library/Frameworks"
              "${apple_sdk}/System/Library/PrivateFrameworks" ];
  };
#+END_SRC

Setup schemas...

#+BEGIN_SRC nix
  schemas = writeText "schemas.xml" ''
  <locatingRules
      xmlns="http://thaiopensource.com/ns/locating-rules/1.0"
  >
    <documentElement localName="section" typeId="DocBook"/>
    <documentElement localName="chapter" typeId="DocBook"/>
    <documentElement localName="article" typeId="DocBook"/>
    <documentElement localName="book" typeId="DocBook"/>
    <typeId id="DocBook"
            uri="${docbook5}/xml/rng/docbook/docbookxi.rnc"
    />
  </locatingRules>
  '';
#+END_SRC

Full list of packages that will be made available.

#+BEGIN_SRC nix
  # git = gitMinimal.override { perlSupport = true; pythonSupport = false; };
  git = gitMinimal;
  userPackages = [
    myAspell

    # From common-path.nix
    coreutils findutils diffutils gnused gnugrep gawk gnutar
    gzip bzip2 gnumake bash patch xz

    # Helpful core tools
    curl zsh cacert file lsof pstree which rsync
    unzip man openssh less calc ag ripgrep sqlite
    git gnuplot gnupg tree cvs subversion

    # Nix tools
    nix nix-index nix-zsh-completions

    watchman
  ] ++ lib.optionals big ([
    # Useful tools
    isync notmuch graphviz indent
    graphviz imagemagick

    bazaar mercurial

    # Programming interpreters/compilers
    myTex rEnv perl python lua coq ocaml
    openjdk nodejs gcc gdb

    travis v8

    # Disabled
    # gcal ocrad mailutils dirmngr jwhois moe
  ] ++ (with netbsd; [ getent getconf ]) # games
    ++ (with nodePackages; [ tern heroku node2nix ])
    ++ (with gitAndTools; [ hub ])
    ++ (with haskellPackages; [ ghc jq nix-diff cabal2nix cabal-install ])
    ++ (with unixtools; [ utillinux nettools procps ])
  );
#+END_SRC

Setup global environment variables & directories. Most of the global
directories will not exist, but the way search paths work, means that is okay.
We aim to support all directories in a common system, prioritizing ones that the
user has the most direct access to.

#+BEGIN_SRC nix
  global-dirs = [ "~/.nix-profile"
                  "~/.local"
                  "/nix/var/nix/profiles/default"
                  "/run/wrappers"
                  "/run/current-system/sw"
                  "/usr/local"
                  "/usr"
                  "" ];

  PATH = lib.concatStringsSep ":" [
           (lib.makeBinPath ([ bins customEmacsPackages.emacs zsh ]
                             ++ global-dirs))
           (lib.makeSearchPath "sbin" [ "/usr" "" ])
         ];
  MANPATH = lib.makeSearchPathOutput "man" "share/man"
    ([ manpages customEmacsPackages.emacs zsh ] ++ global-dirs);
  INFOPATH = "${infopages}/share/info";
  XDG_DATA_DIRS = lib.makeSearchPathOutput "xdg" "share"
    ([ xdg-data ] ++ global-dirs);
#+END_SRC

The actual environment.

#+BEGIN_SRC nix
in buildEnv {
  name = "bauer";
  buildInputs = [ makeWrapper ];
  postBuild = ''
    mkdir -p $out/etc
    substituteAll ${./gitconfig} $out/etc/gitconfig

    # install -D -m 655 ${git}/share/git-core/templates/hooks/fsmonitor-watchman.sample $out/etc/fsmonitor
    # substituteInPlace $out/etc/fsmonitor \
    #   --replace "'watchman -j --no-pretty'" "'${watchman}/bin/watchman -j --no-pretty'"
    # patchShebangs $out/etc/fsmonitor

    substituteAll ${./zshrc.sh} $out/etc/.zshrc
    substituteInPlace $out/etc/.zshrc \
      --subst-var-by completions ${zsh-completions}
    ln -s $out/etc/.zshrc $out/etc/zshrc
    wrapProgram $out/bin/zsh --set ZDOTDIR $out/etc
    substituteAll ${./etc-profile.sh} $out/etc/profile
    substitute ${./runemacs.sh} $out/bin/run \
      --subst-var-by emacs ${myEmacs}
    chmod +x $out/bin/run
    ln -s $out/bin/run $out/bin/bauer
  '';
  pathsToLink = [
    "/bin"
    "/etc/profile.d"
  ] ++ stdenv.lib.optional stdenv.isDarwin "/Applications";
  meta = with lib; {
    description = "Bauer’s automated unified Emacs realm";
    maintainers = with maintainers; [ matthewbauer ];
    platforms = platforms.all;
  };
  passthru = with lib; {
    shellPath = "/bin/zsh";
    run = "/bin/run";
    sourceFile = "/etc/profile.d/profile";
    PATH = makeSearchPath "bin" [bins];
    MANPATH = makeSearchPath "share/man" [manpages];
    INFOPATH = makeSearchPath "share/info" [infopages];
    XDG_DATA_DIRS = makeSearchPath "share" [xdg-data];
  };
  paths = [
    myEmacs zsh
    (runCommand "my-profile" {
      buildInputs = [makeWrapper];
      emacs = myEmacs;
      inherit fortune cacert;
    } ''
      mkdir -p $out/etc/profile.d
      substituteAll ${./profile.sh} $out/etc/profile.d/my-profile.sh
      substituteInPlace $out/etc/profile.d/my-profile.sh \
        --subst-var-by PATH ${PATH} \
        --subst-var-by INFOPATH ${INFOPATH} \
        --subst-var-by MANPATH ${MANPATH} \
        ${lib.optionalString stdenv.isLinux
        "--subst-var-by XDG_DATA_DIRS ${XDG_DATA_DIRS}"}
    '')
  ];
}
#+END_SRC

** Invoking it
We can build it with =nix-build=.

#+BEGIN_SRC shell :results none :tangle no
nix-build
./result/bin/run
#+END_SRC
* Continuous integration
:PROPERTIES:
:CUSTOM_ID: ci
:END:

#+BEGIN_EXPORT html
<a href="https://travis-ci.org/matthewbauer/bauer">
  <img src="https://travis-ci.org/matthewbauer/bauer.svg?branch=master" alt="travis status"></img>
</a>
#+END_EXPORT

We'll set up Travis support here. We start by configuring =.travis.yml=.

** =.travis.yml=
:PROPERTIES:
:header-args: :tangle .travis.yml
:CUSTOM_ID: travis
:END:

#+BEGIN_SRC yaml :padline no
language: nix
#+END_SRC

Next we'll set up nix-build & pass the URL of Nixpkgs with the =NIXPKGS=.

#+BEGIN_SRC yaml
script:
  - nix-build -Q --argstr channel $CHANNEL
#+END_SRC

Setup the OSs. Sadly no Windows support yet.

#+BEGIN_SRC yaml
git:
  depth: 1
sudo: false
os:
  - linux
  - osx
#+END_SRC

Setup some values for =NIXPKGS= variables.

#+BEGIN_SRC yaml
env:
  - CHANNEL=nixos-unstable
  - CHANNEL=nixpkgs-unstable
#+END_SRC

Setup the cache.

#+BEGIN_SRC yaml
cache:
  directories:
    - /nix/store
#+END_SRC

Turn off those annoying Travis notifications.

#+BEGIN_SRC yaml
notifications:
  email: false
#+END_SRC
* Extra
:PROPERTIES:
:CUSTOM_ID: extra
:END:

** =update.sh=
:PROPERTIES:
:header-args: :tangle update.sh :tangle-mode (identity #o755) :shebang "#!/usr/bin/env sh"
:END:

This is a simple script that I use to make sure I've updated the generated
files.

#+BEGIN_SRC shell :padline no
emacs --batch \
      -l ob-tangle \
      --eval "(org-babel-tangle-file \"README.org\")"
emacs README.org --batch -f org-html-export-to-html
#+END_SRC
** =.gitignore=
:PROPERTIES:
:header-args: :tangle .gitignore
:END:

If you end up with generated files, they’re easy to remove with Git. Just run
=git clean -xdf= & it will remove all of the files that match the .gitignore
rules (which should never be added to the git tree).

These set up some paths for =.gitignore= that we don’t want getting put in
the repo. Start with Emacs/org-mode/LaTeX stuff.

#+BEGIN_SRC gitignore :padline no
flycheck_*.el
*.elc
*.pdf
*.html
*.tex
*.log
*.aux
*.out
*.toc
#+END_SRC

Nix-related stuff.

#+BEGIN_SRC gitignore
# nix stuff
result
result-*
#+END_SRC

These are all tangled by [[./README.org][README.org]].

#+BEGIN_SRC gitignore
README.el
bauer.nix
zshrc.sh
etc-profile.sh
runemacs.sh
gitconfig
gitignore
default.el
profile.sh
site-paths.el.in
org-init.el
org-src-*
configuration.nix
install
#+END_SRC

** =.gitattributes=
:PROPERTIES:
:header-args: :tangle .gitattributes
:END:

#+BEGIN_SRC gitattributes :padline no
config.nix     linguist-generated=true
default.nix    linguist-generated=true
bootstrap.sh   linguist-generated=true
install        linguist-generated=true
update.sh      linguist-generated=true
.travis.yml    linguist-generated=true
.gitattributes linguist-generated=true
.gitignore     linguist-generated=true
module.nix     linguist-generated=true
#+END_SRC
** =init.el=

You can use this as [[~/.emacs.d/init.el][your Emacs init file]]:

#+BEGIN_SRC emacs-lisp :tangle init.el
(load
  (expand-file-name "settings.el" user-emacs-directory) t)
(package-initialize)
(defvar bauer-dir
        (expand-file-name ".emacs.d" (getenv "HOME")))
(defvar bauer-org
        (expand-file-name "README.org" bauer-dir))
(add-to-list 'load-path
             (expand-file-name "site-lisp" bauer-dir))
(unless (file-exists-p
          (expand-file-name "README.el" bauer-dir))
  (let ((default-directory bauer-dir))
    (autoload 'org-babel-tangle-file "ob-tangle")
    (org-babel-tangle-file bauer-org
                          "README.el"
                          "emacs-lisp")))
(load (expand-file-name "README.el" bauer-dir) t)
#+END_SRC

** NixOS module

I’ve provided a module suitable for use with a NixOS configuration. To use it,
just add something like the following to your configuration.nix file.

#+BEGIN_SRC nix :tangle no :padline no
# -*- mode: nix; coding: utf-8; -*-
{ ... }:
{
  imports = [
    (builtins.fetchurl "https://matthewbauer.us/bauer/module.nix")
  ];
  programs.bauer.enable = true;
}
#+END_SRC

The actual module implementation follow here. It will pull in some files needed
for all of this to work. It should provide ‘bauer’ as a runnable command.

#+BEGIN_SRC nix :tangle no :padline no
# -*- mode: nix; coding: utf-8; -*-
{ config, lib, pkgs, ... }: with lib;

let
  ensure = f: n: if builtins.pathExists f then f
                 else builtins.fetchurl
    "https://matthewbauer.us/bauer/${n}";
  bauer = import (ensure ./default.nix "default.nix") {
    inherit pkgs;
  };
in {
  options = {
    programs.bauer = {
      enable = mkOption {
        default = false;
        type = types.bool;
      };
    };
  };

  config = mkIf config.programs.bauer.enable {
    environment = {
      systemPackages = [ bauer ];
      variables = with lib; {
        PATH = [bauer.PATH];
        XDG_DATA_DIRS = [bauer.XDG_DATA_DIRS];
        MANPATH = [bauer.MANPATH];
        INFOPATH = [bauer.INFOPATH];
      };
    };
  };
}
#+END_SRC
** TODO VirtualBox & more images
** LICENSE
   License text (bug #1)

   Copyright (C) 2018 Matthew Bauer

   This program is free software: you can redistribute it and/or modify it under
   the terms of the GNU General Public License as published by the Free Software
   Foundation, either version 3 of the License, or (at your option) any later
   version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
   details.

   You should have received a copy of the GNU General Public License along with
   this program. If not, see <http://www.gnu.org/licenses/>.
* COMMENT Footer
# Local Variables:
# mode: org
# bug-reference-url-format: "https://github.com/matthewbauer/bauer/issues/%s"
# coding: utf-8
# compile-command: "nix-build"
# fill-column: 80
# sentence-end-double-space: nil
# indent-tabs-mode: t
# tab-width: 8
# End:
